---
layout:     post
title:      Linux操作系统技术
subtitle:   LVM管理
date:       2020-11-23
author:     李绍俊
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Linux
    - LVM
    - 存储技术
---

# LVM管理

## (1).LVM的工作原理

　　LVM（Logical Volume Manager）逻辑卷管理，是在硬盘分区和文件系统之间添加的一个逻辑层，为文件系统屏蔽下层硬盘分区布局，并提供一个抽象的盘卷，在盘卷上建立文件系统。管理员利用LVM可以在硬盘不用重新分区的情况下动态调整文件系统的大小，并且利用LVM管理的文件系统可以跨越物理硬盘。当服务器添加了新的硬盘后，管理员不必将原有的文件移动到新的硬盘上，而是通过LVM直接扩展文件系统来跨越物理硬盘。

　　LVM就是通过将底层的物理硬盘封装，然后以逻辑卷的方式呈现给上层应用。当我们对底层的物理硬盘进行操作时，不再是针对分区进行操作，而是通过逻辑卷对底层硬盘进行管理操作。

## (2).基础术语

####  　物理存储介质（The physical media）：

LVM存储介质，可以是硬盘分区、整个硬盘、raid阵列或SAN硬盘。设备必须初始化为LVM物理卷，才能与LVM结合使用。

#### 　　物理卷PV（physical volume）：

物理卷就是LVM的基本存储逻辑块，但和基本的物理存储介质比较却包含与LVM相关的管理参数，创建物理卷可以用硬盘分区，也可以用硬盘本身。

#### 卷组VG（Volume Group）：

LVM卷组类似于非LVM系统中的物理硬盘，一个卷组VG由一个或多个物理卷PV组成。可以在卷组VG上建立逻辑卷LV。

#### 逻辑卷LV（logical volume）：

类似于非LVM系统中的硬盘分区，逻辑卷LV建立在卷组VG之上。在逻辑卷LV之上建立文件系统。

#### 物理块PE（physical Extent）：

物理卷PV中可以分配的最小存储单元，PE的大小可以指定，默认为4MB

#### 逻辑块LE（Logical Extent）：

逻辑卷LV中可以分配的最小存储单元，在同一卷组VG中LE的大小和PE是相同的，并且一一相对。

![img](https://upic-lisj.oss-cn-beijing.aliyuncs.com/uPic/1606108927-949069-20200416104045527-1858978940.png)

总结：多个磁盘/分区/raid-->多个物理卷PV-->合成卷组VG-->从VG划分出逻辑卷LV-->格式化LV，挂载使用。

> 注意：老的Linux在创建PV时，需要将分区类型改为Linux LVM（8e）。但新的系统已经非常智能，即使默认的Linux分区（83），也可以创建PV。

## (3).LVM的优点

卷组VG可以使多个硬盘空间看起来像是一个大硬盘。

逻辑卷LV可以创建跨多个硬盘空间的分区。

在使用逻辑卷LV时，可以在空间不足时动态调整大小，不需要考虑逻辑卷LV在硬盘上的位置，不用担心没有可用的连续的空间。

可以在线对卷组VG、逻辑卷LV进行创建、删除、调整大小等操作。但LVM上的文件系统也需要重新调整大小。

LVM允许创建快照，用来保存文件系统的备份。

注意：LVM是软件的卷管理方式，RAID是磁盘管理的方法。对于重要的数据，使用RAID保护物理硬盘不会因为故障而中断业务，再用LVM来实现对卷的良性管理，更好的利用硬盘资源。

　　LVM有两种写入机制：线性（写完一个PV再写下一个PV，默认）、条带（平均）

## (4).创建LVM

#### 1）lvm常用的命令

 

| 功能         | PV管理命令 | VG管理命令 | LV管理命令 |
| ------------ | ---------- | ---------- | ---------- |
| scan 扫描    | pvscan     | vgscan     | lvscan     |
| create 创建  | pvcreate   | vgcreate   | lvcreate   |
| display 显示 | pvdisplay  | vgdisplay  | lvdisplay  |
| remove 移除  | pvremove   | vgremove   | lvremove   |
| extend 扩展  |            | vgextend   | lvextend   |
| reduce 减少  |            | vgreduce   | lvreduce   |

 　注意：查看命令有scan、display和s（pvs、vgs、lvs）。s是简单查看对应卷信息，display是详细查看对应卷信息。而scan是扫描所有的相关的对应卷。

#### 2）环境

 　添加一个20G硬盘sdb，创建四个2G的主分区

```shell
[root@xuexi ~]# ls /dev/sd*
/dev/sda  /dev/sda1  /dev/sda2  /dev/sda3  /dev/sdb

[root@xuexi ~]# fdisk /dev/sdb
欢迎使用 fdisk (util-linux 2.23.2)。
 
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。
 
 
命令(输入 m 获取帮助)：n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
分区号 (1-4，默认 1)：
起始 扇区 (2048-41943039，默认为 2048)：
将使用默认值 2048
Last 扇区, +扇区 or +size{K,M,G} (2048-41943039，默认为 41943039)：+2G
分区 1 已设置为 Linux 类型，大小设为 2 GiB
 
命令(输入 m 获取帮助)：n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): p
分区号 (2-4，默认 2)：
起始 扇区 (4196352-41943039，默认为 4196352)：
将使用默认值 4196352
Last 扇区, +扇区 or +size{K,M,G} (4196352-41943039，默认为 41943039)：+2G
分区 2 已设置为 Linux 类型，大小设为 2 GiB
 
命令(输入 m 获取帮助)：n
Partition type:
   p   primary (2 primary, 0 extended, 2 free)
   e   extended
Select (default p): p
分区号 (3,4，默认 3)：
起始 扇区 (8390656-41943039，默认为 8390656)：
将使用默认值 8390656
Last 扇区, +扇区 or +size{K,M,G} (8390656-41943039，默认为 41943039)：+2G
分区 3 已设置为 Linux 类型，大小设为 2 GiB
 
命令(输入 m 获取帮助)：n
Partition type:
   p   primary (3 primary, 0 extended, 1 free)
   e   extended
Select (default e): p
已选择分区 4
起始 扇区 (12584960-41943039，默认为 12584960)：
将使用默认值 12584960
Last 扇区, +扇区 or +size{K,M,G} (12584960-41943039，默认为 41943039)：+2G
分区 4 已设置为 Linux 类型，大小设为 2 GiB
 
命令(输入 m 获取帮助)：w
The partition table has been altered!
 
Calling ioctl() to re-read partition table.
正在同步磁盘。
[root@xuexi ~]# ls /dev/sd*
/dev/sda   /dev/sda2  /dev/sdb   /dev/sdb2  /dev/sdb4
/dev/sda1  /dev/sda3  /dev/sdb1  /dev/sdb3
```

3）创建物理卷PV

　　将分区sdb1~4从Linux类型改为Linux LVM，当然较新的系统不改也没事。我这里就演示修改一个sdb1分区

```shell
[root@xuexi ~]# fdisk /dev/sdb
欢迎使用 fdisk (util-linux 2.23.2)。
 
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。
 
 
命令(输入 m 获取帮助)：l　　//查看所有分区类型代码
 
 0  空              24  NEC DOS         81  Minix / 旧 Linu bf  Solaris       
 1  FAT12           27  隐藏的 NTFS Win 82  Linux 交换 / So c1  DRDOS/sec (FAT-
 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       3c  PartitionMagic  84  OS/2 隐藏的 C:  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      40  Venix 80286     85  Linux 扩展      c7  Syrinx        
 5  扩展            41  PPC PReP Boot   86  NTFS 卷集       da  非文件系统数据
 6  FAT16           42  SFS             87  NTFS 卷集       db  CP/M / CTOS / .
 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux 纯文本    de  Dell 工具     
 8  AIX             4e  QNX4.x 第2部分  8e  Linux LVM       df  BootIt        
 9  AIX 可启动      4f  QNX4.x 第3部分  93  Amoeba          e1  DOS 访问      
 a  OS/2 启动管理器 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O       
 b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor     
 c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad 休 eb  BeOS fs       
 e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT           
 f  W95 扩展 (LBA)  54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC 
11  隐藏的 FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor     
12  Compaq 诊断     5c  Priam Edisk     a9  NetBSD          f4  SpeedStor     
14  隐藏的 FAT16 <3 61  SpeedStor       ab  Darwin 启动     f2  DOS 次要      
16  隐藏的 FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS   
17  隐藏的 HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE
18  AST 智能睡眠    65  Novell Netware  b8  BSDI swap       fd  Linux raid 自动
1b  隐藏的 W95 FAT3 70  DiskSecure 多启 bb  Boot Wizard 隐  fe  LANstep       
1c  隐藏的 W95 FAT3 75  PC/IX           be  Solaris 启动    ff  BBT           
1e  隐藏的 W95 FAT1 80  旧 Minix      
 
命令(输入 m 获取帮助)：p　　//查看分区信息
 
磁盘 /dev/sdb：21.5 GB, 21474836480 字节，41943040 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x6dc89fe5
 
   设备 Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4196351     2097152   83  Linux
/dev/sdb2         4196352     8390655     2097152   83  Linux
/dev/sdb3         8390656    12584959     2097152   83  Linux
/dev/sdb4        12584960    16779263     2097152   83  Linux
 
命令(输入 m 获取帮助)：t　　//修改分区类型代码
分区号 (1-4，默认 4)：1
Hex 代码(输入 L 列出所有代码)：8e
已将分区“Linux”的类型更改为“Linux LVM”
 
命令(输入 m 获取帮助)：p
 
磁盘 /dev/sdb：21.5 GB, 21474836480 字节，41943040 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x6dc89fe5
 
   设备 Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4196351     2097152   8e  Linux LVM
/dev/sdb2         4196352     8390655     2097152   83  Linux
/dev/sdb3         8390656    12584959     2097152   83  Linux
/dev/sdb4        12584960    16779263     2097152   83  Linux
 
命令(输入 m 获取帮助)：w
The partition table has been altered!
 
Calling ioctl() to re-read partition table.
正在同步磁盘。
```

　　使用pvcreate创建物理卷PV

```shell
[root@xuexi ~]# pvcreate /dev/sdb{1,2,3,4}
WARNING: xfs signature detected on /dev/sdb1 at offset 0. Wipe it? [y/n]: y
  Wiping xfs signature on /dev/sdb1.
  Physical volume "/dev/sdb1" successfully created.
  Physical volume "/dev/sdb2" successfully created.
  Physical volume "/dev/sdb3" successfully created.
  Physical volume "/dev/sdb4" successfully created.
```

　　创建完成后可以查看一下

```shell
[root@xuexi ~]# pvs
  PV         VG Fmt  Attr PSize PFree
  /dev/sdb1     lvm2 ---  2.00g 2.00g
  /dev/sdb2     lvm2 ---  2.00g 2.00g
  /dev/sdb3     lvm2 ---  2.00g 2.00g
  /dev/sdb4     lvm2 ---  2.00g 2.00g
[root@xuexi ~]# pvdisplay /dev/sdb1
  "/dev/sdb1" is a new physical volume of "2.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdb1
  VG Name              
  PV Size               2.00 GiB
  Allocatable           NO
  PE Size               0  
  Total PE              0
  Free PE               0
  Allocated PE          0　　//PE使用情况
  PV UUID               BKr1CG-91rH-0Dsq-vGol-UTO6-xP83-hV7FTZ
```

4）创建卷组VG

　　使用vgcreate创建卷组VG，并且此处可以-s选项指定PE（LE）的大小，（默认PE大小4M）

```shell
[root@xuexi ~]# vgcreate vg1 /dev/sdb1
  Volume group "vg1" successfully created
[root@xuexi ~]# vgcreate -s 16M vg2 /dev/sdb2
  Volume group "vg2" successfully created
```

　　创建完成后查看一下

```shell
[root@xuexi ~]# vgs
  VG  #PV #LV #SN Attr   VSize  VFree
  vg1   1   0   0 wz--n- <2.00g <2.00g
  vg2   1   0   0 wz--n-  1.98g  1.98g
[root@xuexi ~]# vgdisplay vg1
  --- Volume group ---
  VG Name               vg1
  System ID            
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               <2.00 GiB
  PE Size               4.00 MiB　　//可以看到vg1的PE大小为4M
  Total PE              511
  Alloc PE / Size       0 / 0  
  Free  PE / Size       511 / <2.00 GiB
  VG UUID               N0HBAX-50lM-3tJ3-xIho-pLrx-7hAh-1T1T0g
[root@xuexi ~]# vgdisplay vg2
  --- Volume group ---
  VG Name               vg2
  System ID            
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               1.98 GiB
  PE Size               16.00 MiB　　//可以看到vg2的PE大小为16M
  Total PE              127
  Alloc PE / Size       0 / 0
  Free  PE / Size       127 / 1.98 GiB
  VG UUID               ajSIkx-BC9P-ufCn-f7Uc-FXtR-hPq5-tRGBei
```

　　注意：PE大，读取速度快，但浪费空间。反之，读取速度慢，但节省空间。类似于socket

　　另外还可以查看pv，会列出分配情况

```shell
[root@xuexi ~]# pvs
  PV         VG  Fmt  Attr PSize  PFree
  /dev/sdb1  vg1 lvm2 a--  <2.00g <2.00g
  /dev/sdb2  vg2 lvm2 a--   1.98g  1.98g
  /dev/sdb3      lvm2 ---   2.00g  2.00g
  /dev/sdb4      lvm2 ---   2.00g  2.00g
```

5）创建逻辑卷LV

　　使用lvcreate创建LV。lvcreate -n lvname -L lvsize(M，G)|-l LEnumber vgname

```shell
[root@xuexi ~]# lvcreate -n lv1 -L 64M vg1
  Logical volume "lv1" created.
[root@xuexi ~]# lvcreate -n lv2 -l 16 vg1
  Logical volume "lv2" created.

```

　　创建完查看一下

```shell
[root@xuexi ~]# lvs　　//因为vg1的PE大小是4M所以lv1与lv2的大小相等
  LV   VG  Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv1  vg1 -wi-a----- 64.00m
  lv2  vg1 -wi-a----- 64.00m
```

　　此时我们再看下pv和vg的使用情况

```shell
[root@xuexi ~]# pvdisplay /dev/sdb1
  --- Physical volume ---
  PV Name               /dev/sdb1
  VG Name               vg1
  PV Size               2.00 GiB / not usable 4.00 MiB
  Allocatable           yes
  PE Size               4.00 MiB
  Total PE              511
  Free PE               479
  Allocated PE          32
  PV UUID               BKr1CG-91rH-0Dsq-vGol-UTO6-xP83-hV7FTZ
[root@xuexi ~]# vgdisplay vg1
  --- Volume group ---
  VG Name               vg1
  System ID            
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  3
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                2
  Open LV               0
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               <2.00 GiB
  PE Size               4.00 MiB
  Total PE              511
  Alloc PE / Size       32 / 128.00 MiB
  Free  PE / Size       479 / 1.87 GiB
  VG UUID               N0HBAX-50lM-3tJ3-xIho-pLrx-7hAh-1T1T0g
```

6）格式化与挂载

　　注意：在格式化之前需要知道xfs文件系统只支持增大，不支持减小。ext2、ext3、ext4增大减小都支持。

　　所以这里我们先使用ext4的文件系统格式化

```shell
[root@xuexi ~]# mkfs.ext4 /dev/vg1/lv1　　//将lv1格式化成ext4
mke2fs 1.42.9 (28-Dec-2013)
文件系统标签=
OS type: Linux
块大小=1024 (log=0)
分块大小=1024 (log=0)
Stride=0 blocks, Stripe width=0 blocks
16384 inodes, 65536 blocks
3276 blocks (5.00%) reserved for the super user
第一个数据块=1
Maximum filesystem blocks=33685504
8 block groups
8192 blocks per group, 8192 fragments per group
2048 inodes per group
Superblock backups stored on blocks:
    8193, 24577, 40961, 57345
 
Allocating group tables: 完成                           
正在写入inode表: 完成                           
Creating journal (4096 blocks): 完成
Writing superblocks and filesystem accounting information: 完成
[root@xuexi ~]# mkdir /lv1
[root@xuexi ~]# mount /dev/vg1/lv1 /lv1　　//挂载到/lv1下
[root@xuexi ~]# echo "/dev/vg1/lv1 /lv1 ext4 defaults 0 0" >> /etc/fstab    //追加到开机挂载
```

　　这里的/dev/vg1/lv1实际是一个软链接，实际地址如下

```shell
[root@xuexi ~]# ll /dev/vg1/lv1
lrwxrwxrwx. 1 root root 7 3月  31 15:48 /dev/vg1/lv1 -> ../dm-0
[root@xuexi ~]# ll /dev/dm-0
brw-rw----. 1 root disk 253, 0 3月  31 15:48 /dev/dm-0
```

(5).逻辑卷LV扩容（动态扩容）

 　首先需要确认是否有可用的扩容空间，逻辑卷LV是从卷组VG中创建的，所有在逻辑卷LV扩容前需要查看卷组VG的空间使用情况。

```shell
[root@xuexi ~]# vgs
  VG  #PV #LV #SN Attr   VSize  VFree
  vg1   1   2   0 wz--n- <2.00g 1.87g
  vg2   1   0   0 wz--n-  1.98g 1.98g
```

　　在确认有多余空间的情况下，使用lvextend命令的-L选项扩展逻辑卷LV的大小

```shell
[root@xuexi ~]# lvs
  LV   VG  Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv1  vg1 -wi-ao---- 64.00m                                                   
  lv2  vg1 -wi-a----- 64.00m
[root@xuexi ~]# lvextend -L +100M /dev/vg1/lv1　　// +100M是增加100M
  Size of logical volume vg1/lv1 changed from 64.00 MiB (16 extents) to 164.00 MiB (41 extents).
  Logical volume vg1/lv1 successfully resized.
[root@xuexi ~]# lvextend -L 100M /dev/vg1/lv2　　//直接使用100M是增加到100M
  Size of logical volume vg1/lv2 changed from 64.00 MiB (16 extents) to 100.00 MiB (25 extents).
  Logical volume vg1/lv2 successfully resized.
[root@xuexi ~]# lvs
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv1  vg1 -wi-ao---- 164.00m                                                   
  lv2  vg1 -wi-a----- 100.00m
```

　　但是在我们使用df命令查看时，会发现我们文件系统并没有扩展

```
[root@xuexi ~]# df -h /lv1
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv1   58M  1.3M   53M    3% /lv1

```

　　这是因为文件系统也需要扩容。ext4文件系统扩容使用"resize2fs [逻辑卷名称]"，xfs文件系统扩容使用"xfs_growfs 挂载点"

```
[root@xuexi ~]# lvs    //LV已经扩容成功
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv1  vg1 -wi-ao---- 164.00m                                                   
  lv2  vg1 -wi-a----- 100.00m
[root@xuexi ~]# resize2fs /dev/vg1/lv1　　//ext4文件系统扩容
resize2fs 1.42.9 (28-Dec-2013)
Filesystem at /dev/vg1/lv1 is mounted on /lv1; on-line resizing required
old_desc_blocks = 1, new_desc_blocks = 2
The filesystem on /dev/vg1/lv1 is now 167936 blocks long.
[root@xuexi ~]# df -h /lv1
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv1  155M  1.6M  145M    2% /lv1
```

　　当然来到CentOS7后，我们还可以使用lvextend命令的-r选项来使文件系统自动扩容，实例如下：

```
[root@xuexi ~]# lvs
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv1  vg1 -wi-ao---- 164.00m                                                   
  lv2  vg1 -wi-a----- 100.00m
[root@xuexi ~]# lvextend -L 200M -r /dev/vg1/lv1　　//LV扩容到200M并且文件系统自动扩容
  Size of logical volume vg1/lv1 changed from 164.00 MiB (41 extents) to 200.00 MiB (50 extents).
  Logical volume vg1/lv1 successfully resized.　　//可以看到文件系统扩容成功
resize2fs 1.42.9 (28-Dec-2013)
Filesystem at /dev/mapper/vg1-lv1 is mounted on /lv1; on-line resizing required
old_desc_blocks = 2, new_desc_blocks = 2
The filesystem on /dev/mapper/vg1-lv1 is now 204800 blocks long.
[root@xuexi ~]# lvs
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv1  vg1 -wi-ao---- 200.00m                                                   
  lv2  vg1 -wi-a----- 100.00m
[root@xuexi ~]# df -h /lv1
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv1  190M  1.6M  179M    1% /lv1
```

(6).卷组VG扩容

　　卷组的扩容相当简单，一般是LVM空间不够时，添加一块新硬盘时使用。

```
[root@xuexi ~]# vgs
  VG  #PV #LV #SN Attr   VSize  VFree
  vg1   1   2   0 wz--n- <2.00g 1.70g
  vg2   1   0   0 wz--n-  1.98g 1.98g
[root@xuexi ~]# pvs
  PV         VG  Fmt  Attr PSize  PFree
  /dev/sdb1  vg1 lvm2 a--  <2.00g 1.70g
  /dev/sdb2  vg2 lvm2 a--   1.98g 1.98g
  /dev/sdb3      lvm2 ---   2.00g 2.00g
  /dev/sdb4      lvm2 ---   2.00g 2.00g
[root@xuexi ~]# vgextend vg1 /dev/sdb3
  Volume group "vg1" successfully extended
[root@xuexi ~]# vgs
  VG  #PV #LV #SN Attr   VSize VFree
  vg1   2   2   0 wz--n- 3.99g <3.70g
  vg2   1   0   0 wz--n- 1.98g  1.98g
[root@xuexi ~]# pvs
  PV         VG  Fmt  Attr PSize  PFree
  /dev/sdb1  vg1 lvm2 a--  <2.00g  1.70g
  /dev/sdb2  vg2 lvm2 a--   1.98g  1.98g
  /dev/sdb3  vg1 lvm2 a--  <2.00g <2.00g
  /dev/sdb4      lvm2 ---   2.00g  2.00g
```

(7).逻辑卷LV缩小

　　逻辑卷LV缩小命令lvreduce与扩容命令类似，缩减逻辑卷LV请谨慎操作，实例如下：

　　1）lvreduce命令使用-L选项减少空间，-r选项减少文件系统空间，实现动态调整（这是ext4文件系统）

```
[root@xuexi ~]# lvs
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv1  vg1 -wi-ao---- 200.00m                                                   
  lv2  vg1 -wi-a----- 100.00m                                                   
[root@xuexi ~]# lvreduce -L 100M -r /dev/vg1/lv1
Do you want to unmount "/lv1" ? [Y|n] y
fsck，来自 util-linux 2.23.2
/dev/mapper/vg1-lv1: 11/51200 files (9.1% non-contiguous), 12109/204800 blocks
resize2fs 1.42.9 (28-Dec-2013)
Resizing the filesystem on /dev/mapper/vg1-lv1 to 102400 (1k) blocks.
The filesystem on /dev/mapper/vg1-lv1 is now 102400 blocks long.
 
  Size of logical volume vg1/lv1 changed from 200.00 MiB (50 extents) to 100.00 MiB (25 extents).
  Logical volume vg1/lv1 successfully resized.
[root@xuexi ~]# df -h /lv1
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv1   93M  1.6M   85M    2% /lv1
```

　　2）如果不使用-r选项，那么需要卸载挂载点再使用resize2fs调整，但这已经不是动态调整了

```
[root@xuexi ~]# df -h /lv1
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv1   93M  1.6M   85M    2% /lv1
[root@xuexi ~]# lvs
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv1  vg1 -wi-ao---- 100.00m                                                   
  lv2  vg1 -wi-a----- 100.00m                                                   
[root@xuexi ~]# lvreduce -L -20M /dev/vg1/lv1
  WARNING: Reducing active and open logical volume to 80.00 MiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce vg1/lv1? [y/n]: y
  Size of logical volume vg1/lv1 changed from 100.00 MiB (25 extents) to 80.00 MiB (20 extents).
  Logical volume vg1/lv1 successfully resized.
[root@xuexi ~]# resize2fs /dev/vg1/lv1
resize2fs 1.42.9 (28-Dec-2013)
Filesystem at /dev/vg1/lv1 is mounted on /lv1; on-line resizing required
resize2fs: On-line shrinking not supported
[root@xuexi ~]# df -h /lv1　　//失败了
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv1   93M  1.6M   85M    2% /lv1
[root@xuexi ~]# umount /lv1　　//卸载挂载点
[root@xuexi ~]# resize2fs /dev/vg1/lv1
resize2fs 1.42.9 (28-Dec-2013)
Resizing the filesystem on /dev/vg1/lv1 to 81920 (1k) blocks.
The filesystem on /dev/vg1/lv1 is now 81920 blocks long.
[root@xuexi ~]# mount /dev/vg1/lv1 /lv1　　//重新挂载
[root@xuexi ~]# df -h /lv1
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv1   74M  1.6M   67M    3% /lv1

```

　　3）xfs文件系统的实验

```
[root@xuexi ~]# mkfs.xfs /dev/vg1/lv2
meta-data=/dev/vg1/lv2           isize=512    agcount=4, agsize=6400 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=25600, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=855, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@xuexi ~]# mkdir /lv2
[root@xuexi ~]# mount /dev/vg1/lv2 /lv2
[root@xuexi ~]# df -h /lv2
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv2   97M  5.3M   92M    6% /lv2
[root@xuexi ~]# lvs /dev/vg1/lv2
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv2  vg1 -wi-ao---- 100.00m
//使用lvextend的-L选项和-r选项动态扩容
[root@xuexi ~]# lvextend -L +20M -r /dev/vg1/lv2
  Size of logical volume vg1/lv2 changed from 100.00 MiB (25 extents) to 120.00 MiB (30 extents).
  Logical volume vg1/lv2 successfully resized.
meta-data=/dev/mapper/vg1-lv2    isize=512    agcount=4, agsize=6400 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0 spinodes=0
data     =                       bsize=4096   blocks=25600, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal               bsize=4096   blocks=855, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
data blocks changed from 25600 to 30720
[root@xuexi ~]# df -h /lv2
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv2  117M  5.3M  112M    5% /lv2
[root@xuexi ~]# lvs /dev/vg1/lv2
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv2  vg1 -wi-ao---- 120.00m
//使用lvextend和xfs_growfs动态扩容
[root@xuexi ~]# lvextend -L 200M /dev/vg1/lv2
  Size of logical volume vg1/lv2 changed from 120.00 MiB (30 extents) to 200.00 MiB (50 extents).
  Logical volume vg1/lv2 successfully resized.
[root@xuexi ~]# xfs_growfs /lv2
meta-data=/dev/mapper/vg1-lv2    isize=512    agcount=5, agsize=6400 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0 spinodes=0
data     =                       bsize=4096   blocks=30720, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal               bsize=4096   blocks=855, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
data blocks changed from 30720 to 51200
[root@xuexi ~]# df -h /lv2
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv2  197M  5.5M  192M    3% /lv2
[root@xuexi ~]# lvs /dev/vg1/lv2
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv2  vg1 -wi-ao---- 200.00m
//使用lvreduce的-r选项尝试减小空间
[root@xuexi ~]# lvreduce -L -20M -r /dev/vg1/lv2
fsadm: Xfs filesystem shrinking is unsupported.
  /usr/sbin/fsadm failed: 1
  Filesystem resize failed.    //可以看到缩减空间失败了
[root@xuexi ~]# df -h /lv2
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv2  197M  5.5M  192M    3% /lv2
[root@xuexi ~]# lvs /dev/vg1/lv2
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv2  vg1 -wi-ao---- 200.00m
//再试试lvreduce和xfs_growfs组合能不能动态减少空间。这里为什么说动态呢？因为xfs_groefs必须是挂载情况下才能使用，后面跟的是挂载点。
[root@xuexi ~]# lvreduce -L 100M /dev/vg1/lv2
  WARNING: Reducing active and open logical volume to 100.00 MiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce vg1/lv2? [y/n]: Y
  Size of logical volume vg1/lv2 changed from 200.00 MiB (50 extents) to 100.00 MiB (25 extents).
  Logical volume vg1/lv2 successfully resized.
[root@xuexi ~]# xfs_growfs /lv2
meta-data=/dev/mapper/vg1-lv2    isize=512    agcount=8, agsize=6400 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0 spinodes=0
data     =                       bsize=4096   blocks=51200, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal               bsize=4096   blocks=855, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
data size 25600 too small, old size is 51200
[root@xuexi ~]# df -h /lv2　　//一样失败了
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/vg1-lv2  197M   11M  187M    6% /lv2
[root@xuexi ~]# lvs /dev/vg1/lv2
  LV   VG  Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lv2  vg1 -wi-ao---- 100.00m
```

　　所以，xfs文件系统真的只能增大，不能减小。

(8).卷组VG缩小

　　卷组VG的缩小，要查看物理卷PV是否被使用，因为无法缩减一个正在使用的物理卷PV。如下：

```
[root@xuexi ~]# cp /etc/passwd /lv1/　　//复制测试数据
[root@xuexi ~]# ls /lv1/
lost+found  passwd
[root@xuexi ~]# pvs
  PV         VG  Fmt  Attr PSize  PFree
  /dev/sdb1  vg1 lvm2 a--  <2.00g <1.92g
  /dev/sdb2  vg2 lvm2 a--   1.98g  1.98g
  /dev/sdb3  vg1 lvm2 a--  <2.00g <2.00g
  /dev/sdb4      lvm2 ---   2.00g  2.00g
[root@xuexi ~]# vgreduce vg1 /dev/sdb1
  Physical volume "/dev/sdb1" still in use
```

　　此时想要将/dev/sdb1移出vg1，可以使用pvmove命令移动数据，但必须有足够的空间。

```
[root@xuexi ~]# pvmove /dev/sdb1 /dev/sdb3
  /dev/sdb1: Moved: 10.00%
  /dev/sdb1: Moved: 100.00%
[root@xuexi ~]# pvs
  PV         VG  Fmt  Attr PSize  PFree
  /dev/sdb1  vg1 lvm2 a--  <2.00g <2.00g
  /dev/sdb2  vg2 lvm2 a--   1.98g  1.98g
  /dev/sdb3  vg1 lvm2 a--  <2.00g <1.92g
  /dev/sdb4      lvm2 ---   2.00g  2.00g
[root@xuexi ~]# vgreduce vg1 /dev/sdb1
  Removed "/dev/sdb1" from volume group "vg1"
[root@xuexi ~]# pvs
  PV         VG  Fmt  Attr PSize  PFree
  /dev/sdb1      lvm2 ---   2.00g  2.00g
  /dev/sdb2  vg2 lvm2 a--   1.98g  1.98g
  /dev/sdb3  vg1 lvm2 a--  <2.00g <1.92g
  /dev/sdb4      lvm2 ---   2.00g  2.00g
```

　　场景多用于更换旧硬盘。

(9).删除LVM

 　删除LVM步骤：umount卸载-->lvremove移除逻辑卷LV-->vgremove移除卷组VG-->pvremove移除物理卷PV

　　实例：

```
[root@xuexi dev]# umount /lv1　　//卸载挂载点
[root@xuexi dev]# lvremove /dev/vg1/lv1　　//移除逻辑卷
Do you really want to remove active logical volume vg1/lv1? [y/n]: y
  Logical volume "lv1" successfully removed
[root@xuexi dev]# lvs
[root@xuexi dev]# vgremove vg1　　//移除卷组
  Volume group "vg1" successfully removed
[root@xuexi dev]# vgs
  VG  #PV #LV #SN Attr   VSize VFree
  vg2   1   0   0 wz--n- 1.98g 1.98g
[root@xuexi dev]# pvremove /dev/sdb1　　//移除物理卷
  Labels on physical volume "/dev/sdb1" successfully wiped.
[root@xuexi dev]# pvs
  PV         VG  Fmt  Attr PSize PFree
  /dev/sdb2  vg2 lvm2 a--  1.98g 1.98g
  /dev/sdb3      lvm2 ---  2.00g 2.00g
  /dev/sdb4      lvm2 ---  2.00g 2.00g
```

(10).扩展

　　SSM工具：检查关于可用硬盘和LVM卷的信息。显示关于现有磁盘存储设备、存储池、LVM卷和存储快照的信息。

　　1）SSM的安装

```
[root@xuexi ~]# yum -y install system-storage-manager
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
正在解决依赖关系
--> 正在检查事务
---> 软件包 system-storage-manager.noarch.0.0.4-8.el7 将被 安装
--> 解决依赖关系完成
 
依赖关系解决
 
================================================================================
 Package                       架构          版本             源           大小
================================================================================
正在安装:
 system-storage-manager        noarch        0.4-8.el7        base        115 k
 
事务概要
================================================================================
安装  1 软件包
 
总下载量：115 k
安装大小：441 k
Downloading packages:
system-storage-manager-0.4-8.el7.noarch.rpm                | 115 kB   00:01    
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  正在安装    : system-storage-manager-0.4-8.el7.noarch                     1/1
  验证中      : system-storage-manager-0.4-8.el7.noarch                     1/1
 
已安装:
  system-storage-manager.noarch 0:0.4-8.el7                                    
 
完毕！
```

　　2)SSM工具常用命令

　　列出设备信息

```
[root@xuexi ~]# ssm list dev
---------------------------------------------------------
Device        Free     Used      Total  Pool  Mount point
---------------------------------------------------------
/dev/sda                      20.00 GB        PARTITIONED
/dev/sda1                    200.00 MB        /boot     
/dev/sda2                     10.00 GB        /         
/dev/sda3                      2.00 GB        SWAP      
/dev/sdb                      20.00 GB                  
/dev/sdb1                      2.00 GB                  
/dev/sdb2  1.98 GB  0.00 KB    2.00 GB  vg2             
/dev/sdb3                      2.00 GB                  
/dev/sdb4                      2.00 GB                  
---------------------------------------------------------
```

　　列出存储池信息

```
[root@xuexi ~]# ssm list pool
----------------------------------------------
Pool  Type  Devices     Free     Used    Total 
----------------------------------------------
vg2   lvm   1        1.98 GB  0.00 KB  1.98 GB 
----------------------------------------------
```

　　列出卷信息

```
[root@xuexi ~]# ssm list vol
-------------------------------------------------------------------
Volume     Volume size  FS     FS size      Free  TypeMount point 
-------------------------------------------------------------------
/dev/sda1    200.00 MB  xfs  196.66 MB  18.50 MB  part/boot       
/dev/sda2     10.00 GB  xfs    9.99 GB   5.21 GB  part/           
-------------------------------------------------------------------
```

　　3）SSM创建LVM

　　ssm create -s [lv大小] -n [lv名称] --fstype [lv文件系统类型] -p [卷组名] [设备] [挂载点]

 　自动把设备变成pv，创建pv、lv，格式化文件系统，自动挂载

```
[root@xuexi ~]# mkdir /mail-lv
[root@xuexi ~]# ssm create -s 1G -n mail-lv --fstype xfs -p mail /dev/sdb[1-4] /mail-lv
  Physical volume "/dev/sdb1" successfully created.
  Physical volume "/dev/sdb2" successfully created.
  Physical volume "/dev/sdb3" successfully created.
  Physical volume "/dev/sdb4" successfully created.
  Volume group "mail" successfully created
WARNING: ext4 signature detected on /dev/mail/mail-lv at offset 1080. Wipe it? [y/n]: y
  Wiping ext4 signature on /dev/mail/mail-lv.
  Logical volume "mail-lv" created.
meta-data=/dev/mail/mail-lv      isize=512    agcount=4, agsize=65536 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=262144, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@xuexi ~]# df -h /mail-lv/
文件系统                   容量  已用  可用 已用% 挂载点
/dev/mapper/mail-mail--lv 1014M   33M  982M    4% /mail-lv
```





[#3楼](https://www.cnblogs.com/diantong/p/10554831.html#4551391) 2020-04-15 17:09 [zzylekang](https://home.cnblogs.com/u/1583473/)

文章中的配图感觉有误，从物理分区层到PV应该是一对一的吧？

[支持(0) ](javascript:void(0);)[反对(0)](javascript:void(0);)

 

[#4楼](https://www.cnblogs.com/diantong/p/10554831.html#4551433) [楼主] 2020-04-15 17:50 [苦逼运维](https://www.cnblogs.com/diantong/)

[@](https://www.cnblogs.com/diantong/p/10554831.html#4551391)zzylekang
允许多个分区对应一个PV

[支持(0) ](javascript:void(0);)[反对(0)](javascript:void(0);)

 

[#5楼](https://www.cnblogs.com/diantong/p/10554831.html#4551841) 2020-04-16 09:47 [zzylekang](https://home.cnblogs.com/u/1583473/)

[@](https://www.cnblogs.com/diantong/p/10554831.html#4551433)苦逼运维
大神给举个例吧

[支持(0) ](javascript:void(0);)[反对(0)](javascript:void(0);)

 

[#6楼](https://www.cnblogs.com/diantong/p/10554831.html#4551845) [楼主] 2020-04-16 09:49 [苦逼运维](https://www.cnblogs.com/diantong/)

[@](https://www.cnblogs.com/diantong/p/10554831.html#4551841)zzylekang
上面有这个例子，pvcreate /dev/sdb{1,2,3,4}

[支持(0) ](javascript:void(0);)[反对(0)](javascript:void(0);)

 

[#7楼](https://www.cnblogs.com/diantong/p/10554831.html#4551850) [楼主] 2020-04-16 09:50 [苦逼运维](https://www.cnblogs.com/diantong/)

[@](https://www.cnblogs.com/diantong/p/10554831.html#4551841)zzylekang
其实最基本的单位是分区，而不是硬盘

[支持(0) ](javascript:void(0);)[反对(0)](javascript:void(0);)

 

[#8楼](https://www.cnblogs.com/diantong/p/10554831.html#4551861) 2020-04-16 09:55 [zzylekang](https://home.cnblogs.com/u/1583473/)

[@](https://www.cnblogs.com/diantong/p/10554831.html#4551845)苦逼运维

> @zzylekang
> 上面有这个例子，pvcreate /dev/sdb{1,2,3,4}

通过pvs命令会看到4个pv

[支持(0) ](javascript:void(0);)[反对(0)](javascript:void(0);)

 

[#9楼](https://www.cnblogs.com/diantong/p/10554831.html#4551931) [楼主] 2020-04-16 10:36 [苦逼运维](https://www.cnblogs.com/diantong/)

[@](https://www.cnblogs.com/diantong/p/10554831.html#4551861)zzylekang
是我画错了

[支持(1) ](javascript:void(0);)[反对(0)](javascript:void(0);)

 

[#10楼](https://www.cnblogs.com/diantong/p/10554831.html#4552972) 2020-04-17 10:19 [zzylekang](https://home.cnblogs.com/u/1583473/)

[@](https://www.cnblogs.com/diantong/p/10554831.html#4551931)苦逼运维
那张图很直观，👍





---





# lvm 常用命令





## 一，lvm: Logical Volume Manager(逻辑卷管理)

### pv: 物理卷(PE: Physical Extent)

> > 物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘。
>
> > PE:
>
> > 物理区域是物理卷中可用于分配的最小存储单元，物理区域的大小可根据实际情况在建立物理卷时指定。
>
> > 物理区域大小一旦确定将不能更改，同一卷组中的所有物理卷的物理区域大小需要一致。
>
> > 命令：
>
> > ***\*pvcreate /dev/sdb\****  //创建物理卷(VGDA:卷组描述区域)
>
> > **pvcreate /dev/sdc**
>
> > **pvcreate /dev/sd{d,e}**
>
> > **pvscan, pvdisplay** //扫瞄，显示物理卷
>
> > ***\*pvremove /dev/sdb\**** //删除物理卷



###  vg：卷组

> > 卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。
>
> > 一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。
>
> > 命令：
>
> > ***\*vgcreate <volume-group1卷组名> /dev/sdb1 /dev/sdb2 /dev/sdb3\**** //创建卷组
>
> > **vgdisplay** 
>
> > ***\*vgremove  <volume-group1>\**** //删除卷组
>
> > ***\*vgchange -a y\**** // 激活所有卷组
>
> > **vgextend <volume-group1> <pv-path>**  //增大卷组，把新的物理卷加入现在卷组
>
> > **vgreduce <volume-group1> <pv-path>**//减小卷组，把物理卷从卷组中移出
>
> > **卷组的合并与拆分**
>
> > **vgmerge 目的卷组名 源卷组名**#合并两个已经存在的卷组，要求两个卷组的物理区域大小相等且源卷组是非活动的。
>
> > **vgsplit 现有卷组 新卷组**物理卷全路径名[物理卷全路径名]



> ## lv：逻辑卷(LE:Logical Extent)
>
> > 逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。
>
> > LE:逻辑区域是逻辑卷中可用于分配的最小存储单元，逻辑区域的大小取决于逻辑卷所在卷组中的物理区域的大小。
>
> > 系统中的多个逻辑卷要以属于同一个卷组，也可以属于不同的多个卷组。
>
> > 命令：
>
> > ***\*lvcreate -L 100M -n <lv1逻辑卷名>  <volume-group1卷组名>\****   //创建逻辑卷
>
> > **lvdisplay** 
>
> > ***\*lvremove /dev/volume-group1/lv1\****   //删除逻辑卷
>
> > ***\*lvresize -L 200M /dev/volume-group1/lv1\****  // 增大，或 缩小逻辑卷大小
>
> > **lvextend -L|--size +逻辑卷大小增量 逻辑卷全路径名**  //增大
>
> > **lvreduce q -L|--size +逻辑卷减小量 逻辑卷全路径名**  //缩小
>
> > ***\*lvchange -an <logical volume path>\****   //inactive 逻辑卷
>
> > ***\*lvchange -ay <logical volume path>\****//active 激活逻辑卷



> > COW快照：
>
> > ***\*lvcreate -s -n <snapshot name> -L <size of snapshot> <lvm volume for which to take snapshot >\****//创建快照
>
> > ***\*lvconvert --merge <snapshot path>\****//快照rollback
>
> > **如：**
>
> > ***\*lvcreate -s -n snap0 -L 50M /dev/vg0/lv0\****//创建COW快照 (精简卷不能指定大小)
>
> > ***\*lvconvert --merge /dev/vg0/snap0\****//快照回滚

> *注：
> **原生逻辑卷快照(COW快照) 回滚后 就不能再打快照：(可用精简卷)
> **提示：Snapshots of an origin that has a merging snapshot is not supported*

# 二，精简卷：thinly-provisioned LVs

## thinly-provisioned LVs ：原理介绍

是在rhel6.3中作为技术预览引入,在rhel6.5和rhel7中全面支持的lvm技术。

工作原理： 

> 在创建Thin“瘦”卷时，预分配一个虚拟的逻辑卷容量大小，而只是在实际写入数据时才分配物理空间给这个卷。
> 这样我们可以轻易的创建出总逻辑容量超出物理磁盘空间的多个“精简卷”，而无须为将来可能达到的数据量提前“买单”。
> 在应用产生的数据确实需要增加驱动器时，我们也可以灵活地在线调整卷的大小。 


可能带来的问题： 

>  当每个卷已使用的容量总和超过阵列的物理容量时，将无法再写入数据，并导致应用出错。
> 于是设置空间预警的功能就相当重要，比如在物理空间占用达到85%时向管理员发出通知，
> 或者设定自动增长策略，当达到指定阀值，比如85%时，卷自动增长10G。


Thin provisioned的功能：

>  Thin Provisioned的最大特点在于可以对存储资源进行按需动态分配，即对存储进行了虚拟化管理。
>
> 例如，某位用户向服务器管理员请求分配10TB的资源。虽然可能确实需要10TB的物理存储容量，但根据当前使用情况，分配2TB就已足够。
>
> 因此，系统管理员准备2TB的物理存储，并给服务器分配10TB的虚拟卷。服务器即可基于仅占虚拟卷容量1/5的现有物理磁盘池开始运行。
>
> 这样的“始于小”方案能够实现更高效地利用存储容量。

 组成：

>  在标准的逻辑卷中磁盘空间在创建时就会占用卷组的空间，但是在瘦（thin）卷中只有在写入时才会占用存储池"thin pool LV"中的空间。
>  一个 thin逻辑卷创建前必须创建 thin pool LV，一个 thin pool LV由两部分组成：
> 一个大的data LV（数据卷）用来储存数据块，和一个metadate LV（元数据卷）。metadata中记录了thin卷中每个块数据的所属关系。
> （说简单点就是metadata中储存索引，data中储存真实数据，当你访问数据时，先通过索引再访问数据，因为你每次首先访问的不是真实数据，
> 所有就像C语言中链表一样，理论上储存的数据可以无限大，并且动态可调）

## **Thin术语讲解**

>  ThinDataLV：thin数据卷
>
> ​    从卷组中创建的一个比较大的卷
>
> ​    在thin池中来储存thin卷的数据块
>
> ThinMetaLV： thin 元数据卷
>
> ​    从卷组中创建的一个比较小的卷
>
> ​    在thin池来储存块数据的映射关系
>
> ThinPoolLV ：thin池卷，精简池
>
>    由 ThinDataLV 和 ThinMetaLV组成
>
>    包括ThinLVs 和 SnapLV
>
> ThinLV：thin LV 精简卷
>
> ​    由 ThinPoolLV创建(刚开始创建时为空，不实际占有空间)



## 精简卷操作：

> 1，ThinDataLV:创建一个卷作为精简数据卷
> lvcreate --name <pool0> --size 10G <vg0>
> 2, ThinMetaLV:创建一个卷作为精简元数据卷
> lvcreate --name <pool0meta> --size 10G <vg0>
> 3, ThinPoolLV: 创建一个精简池
> lvconvert --thinpool vg/pool0 --poolmetadata vg/pool0meta
> 注：
> a,它把数据卷，元数据卷 合并成一个精简池, 且此精简池使用原数据卷的名字
> b,数据卷会自动隐藏并重命名为ThinPoolLV_tdata
> c,元数据卷会自动隐藏并重命名为ThinPoolLV_tmeta
> lvs -a 可以查看隐藏的名称
> 4,ThinLV: 创建精简卷
> lvcreate --name thin1 -V 1T --thinpool vg/pool0     //创建精简卷thin1
> lvcreate --name thin2 -V 1T  --thinpool vg/pool0//创建精简卷thin2
> 5, 创建精简卷快照
> lvcreate --name <thin1s1快照名> --snapshot vg/thin1  //创建快照
> lvcreate --name <thin1s2>--snapshot vg/thin1
> lvchange  -ay -K /dev/vg/thin1s1//激活精简卷快照(默认不激活时，不可用)
> lvconvert --merge /dev/vg/thin1s1   //快照回滚  (回滚后还可以接着创建快照)  



## **补充：**

> 1，自动设置Thin-pool 的 metadate LV
>
> >  Thin-pool的metadata卷你可以在创建之前手动指定，也可以不指定，由系统自动为你创建，并管理。(需要lvm2-monitor服务启动)
>
> >  如：
>
> > > \# lvcreate --name pool0 --size 10G vg
>
> > > \# lvconvert --thinpool vg/pool0
>
> > > Logical volume "pool0_tmeta" created 
>
> > > Converted vg/pool0 to thin pool. 
>
> 
>
> 
>
> 2， 自动扩展thin pool LV
>
> 一个LVM守护进程（dmeventd）将默认监视thin-pool的LV的数据使用量，达到指定阀值后会自动扩展。
>
> 当然自动扩展的前提是你创建thin-pool的那个卷组中依然有空闲的空间.
>
>  
>
> 使用下面的命令来打开或关闭thin-pool的自动扩展
>
> \#lvchange --monitor {y|n} VG/ThinPoolLV
>
>  
>
> lvm.conf(5) thin_pool_autoextend_threshold
>
> lvm.conf(5) thin_pool_autoextend_percent
>
> 在/etc/lvm/lvm.conf中如上两个参数设置自动扩展的默认设置.
>
>  
>
> thin_pool_autoextend_threshold  这个参数设置了当达到磁盘使用的多少阀值后，自动扩展。
>
> 如果把它设置成 100 就是关闭自动扩展. 最小的值是50.
>
>  
>
> thin_pool_autoextend_percent 定义了每次达到上面定义的阀值后自动扩展多大的空间, 在其当前的规模上扩展百分之几.
>
>  
>
> ​     警告日志是当你的thin-pool达到80%, 85%, 90% and 95%，时发出的.
>
>  
>
> ​     Example
>
> ​    如果 thin_pool_autoextend_threshold 设置成70 同时 thin_pool_autoextend_percent 设置成20, 当thin-pool达到70%使用, 它会再自动扩展 20%.  比如1G的thin-pool, 使用700M时，它会自动变为1.2G. 当它的使用达到 840M,这个池会扩展变为 1.44G, 等等。 
>
>  
>
>   数据空间耗尽
>
> ​    如果数据空间耗尽, 写数据队列会进入等待状态，不能写，可以扩大磁盘使恢复正常， 读操作依然是正常的。数据空间耗尽一般不会引起数据的损坏。 
>
> ​     当数据空间被耗尽的时候使用lvs命令会显示thin-pool是%100的:
>
> ​    \# lvs vg/pool0
>
> ​     LV   VG      Attr    LSize  Pool  Origin Data%
>
> ​     pool0  vg      twi-a-tz-- 512.00m        100.00
>
>    一个thin-pool数据空间耗尽可能是由以下原因造成的:
>
> \1. 自动扩展是关闭的, 并且没有手动扩展Thin-pool.  (关闭自动扩展是不推荐的)
>
> \2. The dmeventd daemon is not running and the thin pool is not manually extended.  (Disabling dmeventd is not recommended.)
>
> \3. Automatic extension of the thin pool is too slow given the rate of
>
> ​    writes to thin LVs in the pool.  (This can be addressed by tuning the
>
> ​    thin_pool_autoextend_threshold and thin_pool_autoextend_percent.)
>
> \4. The VG does not have enough free blocks to extend the thin pool.
>
> ​    The response to data space exhaustion is to extend the thin pool.
>
> ​    This is described in the section "Manually manage free data space of
>
> ​    thin pool LV".
>
>  
>
>   Metadata 空间耗尽
>
> ​    如果元数据空间耗尽(或者元数据空间出错), 回返回磁盘IO出错的提示.
>
> ​     当元数据空间被耗尽的时候，lvs命令会显示 100%的Meta%在thin-pool :
>
> ​     \# lvs -o lv_name,size,data_percent,metadata_percent vg/pool0
>
> ​     LV   LSize Data%  Meta%
>
> ​      pool0        100.00
>
>  
>
> ​    数据空间耗尽出现的情况同样适用于元数据空间耗尽，但是元数据空间耗尽更危险。
>
>  元数据空间耗尽可能会引起数据的索引和数据的指向出现不一致，因此需要立即卸载分区后，检查和修复数据。
>
> ​    \1. Deactivate the thin pool LV, or reboot the system if this is not possible.
>
> ​    \2. Repair thin pool with lvconvert --repair.
>
> ​     See "Metadata check and repair".
>
> ​    \3. Extend pool metadata space with lvextend VG/ThinPoolLV_tmeta.
>
> ​     See "Manually manage free metadata space of a thin pool LV".
>
> ​    \4. Check and repair file system with fsck.



参考：

https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Logical_Volume_Manager_Administration/index.html





---





# LVM 的自定义报告（pvs vgs lvs各参数详解）



分类专栏： [linux](https://blog.csdn.net/qq_22510521/category_6822643.html)

可使用 `pvs`、`lvs` 和 `vgs` 命令生成简洁且可自定义的 LVM 对象报告。这些命令生成的报告包括每行一个对象的输出结果。每行包含与该对象有关的属性字段顺序列表。有五种方法可用来选择要报告的对象：即根据物理卷、卷组、逻辑卷、物理卷片段及逻辑卷片段报告。

以下小节提供：

- 用来控制所生成报告格式的命令参数概述。
- 可为每个 LVM 对象选择的字段列表。
- 可用来对生成的报告进行排序的命令参数概述。
- 指定报告输出结果单位简介。

### 4.8.1. 格式控制

是否使用 `pvs`、`lvs` 或者 `vgs` 命令可决定显示字段的默认设置及排序顺序。可使用下面的参数控制这些命令的输出结果：

- 可使用 `-o` 参数将显示的字段改为默认值以外的内容。例如：下面的输出结果是 `pvs`命令的默认显示内容（即显示物理卷信息）。

  ```
  # pvs
    PV         VG     Fmt  Attr PSize  PFree
    /dev/sdb1  new_vg lvm2 a-   17.14G 17.14G
    /dev/sdc1  new_vg lvm2 a-   17.14G 17.09G
    /dev/sdd1  new_vg lvm2 a-   17.14G 17.14G
  ```

  下面的命令只显示物理卷名称和大小。

  ```
  # pvs -o pv_name,pv_size
    PV         PSize
    /dev/sdb1  17.14G
    /dev/sdc1  17.14G
    /dev/sdd1  17.14G
  ```

- 可将加号（+）于 -o 参数合用，在输出结果中附加一个字段。

  下面的示例除显示默认字段外还显示该物理卷的 UUID。

  ```
  # pvs -o +pv_uuid
    PV         VG     Fmt  Attr PSize  PFree  PV UUID
    /dev/sdb1  new_vg lvm2 a-   17.14G 17.14G onFF2w-1fLC-ughJ-D9eB-M7iv-6XqA-dqGeXY
    /dev/sdc1  new_vg lvm2 a-   17.14G 17.09G Joqlch-yWSj-kuEn-IdwM-01S9-X08M-mcpsVe
    /dev/sdd1  new_vg lvm2 a-   17.14G 17.14G yvfvZK-Cf31-j75k-dECm-0RZ3-0dGW-UqkCS
  ```

- 在命令中添加 `-v` 参数可显示额外的字段。例如：`pvs -v` 命令会在默认字段外显示 `DevSize` 和 `PV UUID` 字段。

  ```
  # pvs -v
      Scanning for physical volume names
    PV         VG     Fmt  Attr PSize  PFree  DevSize PV UUID
    /dev/sdb1  new_vg lvm2 a-   17.14G 17.14G  17.14G onFF2w-1fLC-ughJ-D9eB-M7iv-6XqA-dqGeXY
    /dev/sdc1  new_vg lvm2 a-   17.14G 17.09G  17.14G Joqlch-yWSj-kuEn-IdwM-01S9-XO8M-mcpsVe
    /dev/sdd1  new_vg lvm2 a-   17.14G 17.14G  17.14G yvfvZK-Cf31-j75k-dECm-0RZ3-0dGW-tUqkCS
  ```

- `--noheadings` 参数会取消标题行。这在编写脚本时有用。

  下面的示例将 `--noheadings` 参数与 `pv_name` 参数联合使用生成所有物理卷的列表：

  ```
  # pvs --noheadings -o pv_name
    /dev/sdb1
    /dev/sdc1
    /dev/sdd1
  ```

- `--separator *separator*` 参数使用 *separator* 分离各个字段。

  下面的示例使用等号（=）分离 `pvs` 命令的默认输出字段。

  ```
  # pvs --separator =
    PV=VG=Fmt=Attr=PSize=PFree
    /dev/sdb1=new_vg=lvm2=a-=17.14G=17.14G
    /dev/sdc1=new_vg=lvm2=a-=17.14G=17.09G
    /dev/sdd1=new_vg=lvm2=a-=17.14G=17.14G
  ```

  要在使用 `separator` 参数时保持字段对齐，请将 `separator` 参数与 `--aligned` 参数配合使用。

  ```
  # pvs --separator = --aligned
    PV        =VG    =Fmt =Attr=PSize =PFree
    /dev/sdb1 =new_vg=lvm2=a-  =17.14G=17.14G
    /dev/sdc1 =new_vg=lvm2=a-  =17.14G=17.09G
    /dev/sdd1 =new_vg=lvm2=a-  =17.14G=17.14G
  ```

可使用 `lvs` 或者 `vgs` 命令的 `-P` 参数显示有关失败卷的信息，否则该信息不会出现在输出结果中。有关这个参数字段的输出结果详情，请查看 [第 6.2 节 “在失败的设备中显示信息。”](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/partial_output)。

有关完整显示参数列表，请查看 `pvs`(8)、`vgs`(8) 和 `lvs`(8) man page。

卷组字段可与物理卷（和物理卷片段）字段或者逻辑卷（和逻辑卷片段）字段混合，但物理卷和逻辑卷字段不能混合。例如：下面的命令会每行显示一个物理卷的输出结果。

```
# vgs -o +pv_name
  VG     #PV #LV #SN Attr   VSize  VFree  PV
  new_vg   3   1   0 wz--n- 51.42G 51.37G /dev/sdc1
  new_vg   3   1   0 wz--n- 51.42G 51.37G /dev/sdd1
  new_vg   3   1   0 wz--n- 51.42G 51.37G /dev/sdb1
```

### 4.8.2. 对象选择

本小节提供可用来使用 `pvs`、`vgs` 和 `lvs` 命令显示 LVM 对象信息的表格。

为方便起见，如果字段名称前缀与该命令的默认匹配，则可将其去掉。例如：在 `pvs` 命令中，`name` 的含义是 `pv_name`，但在 `vgs` 命令中，会将 `name` 解读为 `vg_name`。

执行下面的命令与执行 `pvs -o pv_free` 等同。

```
# pvs -o free
  PFree
  17.14G
  17.09G
  17.14G
```

**注意**

在之后的发行本中，`pvs`、`vgs` 和 `lvs` 输出结果中 attribute 字段中的字符数可能会增加。现有字符字段不会更改位置，但可在结尾处添加新字段。为具体属性字符编写脚本时应考虑这个因素，并根据字符与该字段起始位置的相对位置搜索字符，而不是根据其与该字段的截止位置的相对位置进行搜索。例如：要在 `lv_attr` 字段的第九个字节搜索字符 `p`，可搜索字符串 "^/........p/"，但不应搜索字符串 "/*p$/"。

pvs 命令



[表 4.2 “pvs Display 字段”](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/custom_report#tb-table-pvs-fields) 列出 `pvs` 目录的显示参数以及在标头显示中出现的字段名称及该字段的描述。

**表 4.2. pvs Display 字段**

| 参数                | 标头    | 描述                                     |
| :------------------ | :------ | :--------------------------------------- |
| `dev_size`          | DevSize | 该物理卷所在底层设备的大小               |
| `pe_start`          | 1st PE  | 底层设备中的第一个物理扩展偏差           |
| `pv_attr`           | Attr    | 物理卷状态：（a）可分配；或者（x）导出。 |
| `pv_fmt`            | Fmt     | 物理卷元数据格式（`lvm2` 或者 `lvm1`）   |
| `pv_free`           | PFree   | 物理卷中的剩余空间                       |
| `pv_name`           | PV      | 物理卷名称                               |
| `pv_pe_alloc_count` | Alloc   | 已使用物理扩展数                         |
| `pv_pe_count`       | PE      | 物理扩展数                               |
| `pvseg_size`        | SSize   | 物理卷的片段大小                         |
| `pvseg_start`       | 起始    | 物理卷片段的起始物理扩展                 |
| `pv_size`           | PSize   | 物理卷大小                               |
| `pv_tags`           | PV 标签 | 附加到物理卷的 LVM 标签                  |
| `pv_used`           | 已使用  | 该物理卷中目前已使用的空间数量           |
| `pv_uuid`           | PV UUID | 该物理卷的 UUID                          |

`pvs` 命令默认显示以下字段：`pv_name`, `vg_name`, `pv_fmt`, `pv_attr`, `pv_size`, `pv_free`。该显示结果按 `pv_name` 排序。

```
# pvs
  PV         VG     Fmt  Attr PSize  PFree
  /dev/sdb1  new_vg lvm2 a-   17.14G 17.14G
  /dev/sdc1  new_vg lvm2 a-   17.14G 17.09G
  /dev/sdd1  new_vg lvm2 a-   17.14G 17.13G
```

使用 `pvs` 命令的 `-v` 参数值默认显示中添加以下字段：`dev_size`，`pv_uuid`。

```
# pvs -v
    Scanning for physical volume names
  PV         VG     Fmt  Attr PSize  PFree  DevSize PV UUID
  /dev/sdb1  new_vg lvm2 a-   17.14G 17.14G  17.14G onFF2w-1fLC-ughJ-D9eB-M7iv-6XqA-dqGeXY
  /dev/sdc1  new_vg lvm2 a-   17.14G 17.09G  17.14G Joqlch-yWSj-kuEn-IdwM-01S9-XO8M-mcpsVe
  /dev/sdd1  new_vg lvm2 a-   17.14G 17.13G  17.14G yvfvZK-Cf31-j75k-dECm-0RZ3-0dGW-tUqkCS
```

可使用 `pvs` 命令的 `--segments` 参数显示每个物理卷片段的信息。一个片段就是一个扩展组。如果要了解逻辑卷是否碎片化，查看片段视图很有帮助。

`pvs --segments` 命令默认显示以下字段：`pv_name`, `vg_name`, `pv_fmt`, `pv_attr`, `pv_size`, `pv_free`, `pvseg_start`, `pvseg_size`。结果根据物理卷中的 `pv_name` 和 `pvseg_size` 排序。

```
# pvs --segments
  PV         VG         Fmt  Attr PSize  PFree  Start SSize
  /dev/hda2  VolGroup00 lvm2 a-   37.16G 32.00M     0  1172
  /dev/hda2  VolGroup00 lvm2 a-   37.16G 32.00M  1172    16
  /dev/hda2  VolGroup00 lvm2 a-   37.16G 32.00M  1188     1
  /dev/sda1  vg         lvm2 a-   17.14G 16.75G     0    26
  /dev/sda1  vg         lvm2 a-   17.14G 16.75G    26    24
  /dev/sda1  vg         lvm2 a-   17.14G 16.75G    50    26
  /dev/sda1  vg         lvm2 a-   17.14G 16.75G    76    24
  /dev/sda1  vg         lvm2 a-   17.14G 16.75G   100    26
  /dev/sda1  vg         lvm2 a-   17.14G 16.75G   126    24
  /dev/sda1  vg         lvm2 a-   17.14G 16.75G   150    22
  /dev/sda1  vg         lvm2 a-   17.14G 16.75G   172  4217
  /dev/sdb1  vg         lvm2 a-   17.14G 17.14G     0  4389
  /dev/sdc1  vg         lvm2 a-   17.14G 17.14G     0  4389
  /dev/sdd1  vg         lvm2 a-   17.14G 17.14G     0  4389
  /dev/sde1  vg         lvm2 a-   17.14G 17.14G     0  4389
  /dev/sdf1  vg         lvm2 a-   17.14G 17.14G     0  4389
  /dev/sdg1  vg         lvm2 a-   17.14G 17.14G     0  4389
```

可使用 `pvs -a` 命令查看已被 LVM 探测到但尚未初始化为 LVM 物理卷的设备。

```
# pvs -a
  PV                             VG     Fmt  Attr PSize  PFree
  /dev/VolGroup00/LogVol01                   --       0      0
  /dev/new_vg/lvol0                          --       0      0
  /dev/ram                                   --       0      0
  /dev/ram0                                  --       0      0
  /dev/ram2                                  --       0      0
  /dev/ram3                                  --       0      0
  /dev/ram4                                  --       0      0
  /dev/ram5                                  --       0      0
  /dev/ram6                                  --       0      0
  /dev/root                                  --       0      0
  /dev/sda                                   --       0      0
  /dev/sdb                                   --       0      0
  /dev/sdb1                      new_vg lvm2 a-   17.14G 17.14G
  /dev/sdc                                   --       0      0
  /dev/sdc1                      new_vg lvm2 a-   17.14G 17.09G
  /dev/sdd                                   --       0      0
  /dev/sdd1                      new_vg lvm2 a-   17.14G 17.14G
```

vgs 命令



[表 4.3 “vgs Display 字段”](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/custom_report#tb-table-vgs-fields) 列出 `vgs` 命令的显示参数以及在标头显示中出现的字段名称及该字段的描述。

**表 4.3. vgs Display 字段**

| 参数              | 标头    | 描述                                                         |
| :---------------- | :------ | :----------------------------------------------------------- |
| `lv_count`        | #LV     | 卷组所包含逻辑卷数                                           |
| `max_lv`          | MaxLV   | 卷组允许的最大逻辑卷数（0 表示无限大）                       |
| `max_pv`          | MaxPV   | 卷组允许的最大物理卷数（0 表示无限）                         |
| `pv_count`        | #PV     | 定义该卷组的物理卷数                                         |
| `snap_count`      | #SN     | 卷组包含的快照数                                             |
| `vg_attr`         | Attr    | 卷组状态：（w）可写入；（r）只读；（z）可重新定义大小；（x）可导出；（p）部分；以及（c）集群。 |
| `vg_extent_count` | #Ext    | 卷组中的物理扩展数                                           |
| `vg_extent_size`  | Ext     | 卷组中的物理扩展大小                                         |
| `vg_fmt`          | Fmt     | 卷组的元数据格式（`lvm2` 或者 `lvm1`）                       |
| `vg_free`         | VFree   | 卷组中剩余的可用空间大小                                     |
| `vg_free_count`   | 可用    | 卷组中的可用物理扩展数                                       |
| `vg_name`         | VG      | 卷组名称                                                     |
| `vg_seqno`        | Seq     | 代表卷组修改的次数                                           |
| `vg_size`         | VSize   | 卷组大小                                                     |
| `vg_sysid`        | SYS ID  | LVM1 System ID                                               |
| `vg_tags`         | VG 标签 | 附加到卷组的 LVM 标签                                        |
| `vg_uuid`         | VG UUID | 卷组的 UUID                                                  |

`vgs` 命令默认显示以下字段：`vg_name`, `pv_count`, `lv_count`, `snap_count`, `vg_attr`, `vg_size`, `vg_free`. The display is sorted by `vg_name`。

```
# vgs
  VG     #PV #LV #SN Attr   VSize  VFree
  new_vg   3   1   1 wz--n- 51.42G 51.36G
```

使用 `vgs` 命令的 `-v` 参数值默认显示着添加以下字段：`vg_extent_size`，`vg_uuid`。

```
# vgs -v
    Finding all volume groups
    Finding volume group "new_vg"
  VG     Attr   Ext   #PV #LV #SN VSize  VFree  VG UUID
  new_vg wz--n- 4.00M   3   1   1 51.42G 51.36G jxQJ0a-ZKk0-OpMO-0118-nlwO-wwqd-fD5D32
```

lvs 命令



[表 4.4 “lvs 显示字段”](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/custom_report#tb-table-lvs-fields) 列出了 `lvs` 命令的显示参数以及在标头显示中的字段名称以及该字段的描述。



**表 4.4. lvs 显示字段**

| 参数                      | 标头     | 描述                                                         |
| :------------------------ | :------- | :----------------------------------------------------------- |
| `chunksize``chunk_size`   | 区块     | 快照卷的单位大小                                             |
| `copy_percent`            | Copy%    | 镜像逻辑卷的同步百分比；也可在使用 `pv_move` 命令移动物理扩展时使用。 |
| `devices`                 | 设备     | 组成逻辑卷的底层设备：即物理卷、逻辑卷及起始物理扩展和逻辑扩展 |
| `lv_attr`                 | Attr     | 逻辑卷状态。逻辑卷的属性字节如下：字节 1：卷类型： (m)镜像卷，(M) 没有初始同步的镜像卷，(o)原始卷，(O)附带合并快照的原始卷，(r)阵列，(R)没有初始同步的阵列，(s)快照，(S)合并快照，(p)pvmove，(v)虚拟，(i)镜像或阵列映象，(I)未同步的镜像或阵列映象，(l)映象日志设备，(c)底层转换卷，(V)精简卷，(t)精简池，(T)精简池数据，(e)阵列或精简池元数据或池元数据备件，字节 2：授权：(w)写入，(r)只读，(R)非只读卷的只读激活字节 3：分配策略：(a)任意位置，(c)相邻，(i)继承，(l)紧邻，(n)常规。如果该卷目前锁定无法进行分配更改，则该字母会呈大写状态。例如执行 `pvmove` 命令时。字节 4：(m)固定镜像字节 5：状态：(a)激活， (s)挂起, (I) 无效快照， (S) 无效挂起快照， (m) 快照合并失败，(M) 挂起快照合并失败，(d) 显示的映射设备不包含表格，(i) 显示的映射设备中包含停用表格。字节 6：设备 (o) 开启字节 7：目标类型： (m)镜像，(r) RAID，(s) 快照，(t) 精简，(u)未知，(v) 虚拟。这样可将有类似内核目标的逻辑卷分在一组。比如镜像映象、镜像日志以及镜像本身分为组（m），它们使用原始设备映射器内核驱动程序，使用 md raid 内核驱动程序的类似的 raid 设备则分组为（r）。使用原始设备映射器驱动程序的快照则分组为（s），使用精简配置驱动程序的精简卷快照则分组为（t）。字节 8：使用前，以设置为 0 的块覆盖新分配了数据的块。字节 9：卷正常情况：(p) 部分正常，(r) 需要刷新，(m) 存在映射错误，(w) 大部分写入。(p) 部分正常表示该系统中缺少这个逻辑卷使用的一个或多个物理卷。(p) 部分正常表示这个 RAID 逻辑卷使用的一个或多个物理卷有写入错误。该写入错误可能是由于该物理卷故障造成，也可能表示该物理卷正在出现问题。应刷新或替换该设备。(m) 存在映射错误表示 RAID 逻辑卷中有阵列不一致的部分。在 RAID 逻辑卷中启动 `check` 操作就会发现这些不一致之处。（取消该操作，可使用 `lvchange` 命令在 RAID 逻辑卷中执行 `check` 和 `repair` ）。(w) 大部分写入表示已将 RAID 1 逻辑卷中的设备标记为大部分写入。字节 10：(k) 跳过激活：将该卷标记为在激活过程中跳过。 |
| `lv_kernel_major`         | KMaj     | 逻辑卷的实际主要设备数（若未激活则为 -1）                    |
| `lv_kernel_minor`         | KMIN     | 逻辑卷的实际次要设备数（若未激活则为 -1）                    |
| `lv_major`                | Maj      | 逻辑卷的持久主要设备数（若未指定则为 -1）                    |
| `lv_minor`                | Min      | 逻辑卷的持久次要设备数（若未指定则为 -1）                    |
| `lv_name`                 | LV       | 逻辑卷名称                                                   |
| `lv_size`                 | LSize    | 逻辑卷大小                                                   |
| `lv_tags`                 | LV 标签  | 附加到逻辑卷的 LVM 标签                                      |
| `lv_uuid`                 | LV UUID  | 逻辑卷的 UUID                                                |
| `mirror_log`              | Log      | 镜像日志所在设备                                             |
| `modules`                 | 模块     | 需要使用这个逻辑卷的对应内核设备映射器目标                   |
| `move_pv`                 | 移动     | 使用 `pvmove` 命令创建的临时逻辑卷之源物理卷                 |
| `origin`                  | Origin   | 快照卷的原始设备                                             |
| `regionsize``region_size` | 区域     | 镜像逻辑卷的单元大小                                         |
| `seg_count`               | #Seg     | 逻辑卷中的片段数                                             |
| `seg_size`                | SSize    | 逻辑卷的片段大小                                             |
| `seg_start`               | 起始     | 逻辑卷中的片段偏移                                           |
| `seg_tags`                | Seg 标签 | 附加到逻辑卷片段的 LVM 标签                                  |
| `segtype`                 | 类型     | 逻辑卷的片段类型（例如：镜像、条带、线性）                   |
| `snap_percent`            | Snap%    | 目前使用的快照卷百分比                                       |
| `stripes`                 | #Str     | 逻辑卷中的条状卷或镜像卷数                                   |
| `stripesize``stripe_size` | 条带     | 条带逻辑卷的单元大小                                         |

`lvs` 命令默认显示下面的字段：`lv_name`、`vg_name`、`lv_attr`、`lv_size`、`origin`、`snap_percent`、`move_pv`、`mirror_log`、`copy_percent`、`convert_lv`。默认根据卷组中的 `vg_name` 和 `lv_name` 排序。

```
# lvs
  LV         VG     Attr   LSize  Origin Snap%  Move Log Copy%  Convert
  lvol0      new_vg owi-a- 52.00M
  newvgsnap1 new_vg swi-a-  8.00M lvol0    0.20
```

使用 `lvs` 命令的 `-v` 参数将下面的字段添加到默认显示中：`seg_count`、`lv_major`、`lv_minor`、`lv_kernel_major`、`lv_kernel_minor`、`lv_uuid`。

```
# lvs -v
    Finding all logical volumes
  LV         VG     #Seg Attr   LSize  Maj Min KMaj KMin Origin Snap%  Move Copy%  Log Convert LV UUID
  lvol0      new_vg    1 owi-a- 52.00M  -1  -1 253  3                                          LBy1Tz-sr23-OjsI-LT03-nHLC-y8XW-EhCl78
  newvgsnap1 new_vg    1 swi-a-  8.00M  -1  -1 253  5    lvol0    0.20                         1ye1OU-1cIu-o79k-20h2-ZGF0-qCJm-CfbsIx
```

可使用 `lvs` 命令的 `--segments` 参数显示默认栏信息，并强调片段信息。使用 `segments` 参数后，`seg` 前缀为自选项。`lvs --segments` 命令默认显示下面的字段：`lv_name`、`vg_name`、`lv_attr`、`stripes`、`segtype`、`seg_size`。默认显示是根据卷组的 `vg_name` 和 `lv_name`，以及该逻辑卷的 `seg_start` 排序。如果逻辑卷碎片化，这个命令的输出结果会体现此状态。

```
# lvs --segments
  LV       VG         Attr   #Str Type   SSize
  LogVol00 VolGroup00 -wi-ao    1 linear  36.62G
  LogVol01 VolGroup00 -wi-ao    1 linear 512.00M
  lv       vg         -wi-a-    1 linear 104.00M
  lv       vg         -wi-a-    1 linear 104.00M
  lv       vg         -wi-a-    1 linear 104.00M
  lv       vg         -wi-a-    1 linear  88.00M
```

使用 `lvs --segments` 命令的 `-v` 参数在默认显示着添加以下字段：`seg_start`、`stripesize`、`chunksize`。

```
# lvs -v --segments
    Finding all logical volumes
  LV         VG     Attr   Start SSize  #Str Type   Stripe Chunk
  lvol0      new_vg owi-a-    0  52.00M    1 linear     0     0
  newvgsnap1 new_vg swi-a-    0   8.00M    1 linear     0  8.00K
```

下面的示例演示了在已配置逻辑卷的系统中运行 `lvs` 命令的输出结果，以及运行附加 `segments` 参数的 `lvs` 命令的输出结果。

```
# lvs
  LV    VG     Attr   LSize  Origin Snap%  Move Log Copy%
  lvol0 new_vg -wi-a- 52.00M
# lvs --segments
  LV    VG     Attr   #Str Type   SSize
  lvol0 new_vg -wi-a-    1 linear 52.00M
```

### 4.8.3. 将 LVM 报告排序



通常必须生成 `lvs`、`vgs` 或者 `pvs` 命令的整个输出结果，并在可将其排序并正确对齐前保存。可指定 `--unbuffered` 参数在生成后即刻显示未排序的输出结果。

要制定可替换的列排序顺序，请使用任意报告命令的 `-O` 参数。不一定要在输出结果中包含这些字段。

以下示例显示 `pvs` 命令的输出结果，其中显示内容包括物理卷名称、大小及可用空间。

```
# pvs -o pv_name,pv_size,pv_free
  PV         PSize  PFree
  /dev/sdb1  17.14G 17.14G
  /dev/sdc1  17.14G 17.09G
  /dev/sdd1  17.14G 17.14G
```

以下示例显示同样的输出结果，但根据可用空间字段排序。

```
# pvs -o pv_name,pv_size,pv_free -O pv_free
  PV         PSize  PFree
  /dev/sdc1  17.14G 17.09G
  /dev/sdd1  17.14G 17.14G
  /dev/sdb1  17.14G 17.14G
```

以下示例表示不需要显示用来排序的字段内容。

```
# pvs -o pv_name,pv_size -O pv_free
  PV         PSize
  /dev/sdc1  17.14G
  /dev/sdd1  17.14G
  /dev/sdb1  17.14G
```

要显示反向排序，请在 `-O` 参数前指定 的字段前添加 `-` 字符。

```
# pvs -o pv_name,pv_size,pv_free -O -pv_free
  PV         PSize  PFree
  /dev/sdd1  17.14G 17.14G
  /dev/sdb1  17.14G 17.14G
  /dev/sdc1  17.14G 17.09G
```

### 4.8.4. 指定单位

要指定 LVM 报告显示的单位，请使用该报告命令的 `--units` 参数。可指定 (b)、(k)、(m)、(g)、(t)、(e)xabytes、(p) 和 (h)。默认显示为 human-readable（用户可读）。可在 `lvm.conf` 文件的 `global` 部分设置 `units` 参数覆盖默认值。

以下示例采用 MB 指定 `pvs` 命令的输出结果，而不是默认的 GB。

```
# pvs --units m
  PV         VG     Fmt  Attr PSize     PFree
  /dev/sda1         lvm2 --   17555.40M 17555.40M
  /dev/sdb1  new_vg lvm2 a-   17552.00M 17552.00M
  /dev/sdc1  new_vg lvm2 a-   17552.00M 17500.00M
  /dev/sdd1  new_vg lvm2 a-   17552.00M 17552.00M
```

默认情况是以 2 的次方数（1024 的倍数）显示单位。可使用大写单位（B、K、M、G、T、H）以 1000 的倍数显示单位。

下面的命令采用 1024 的倍数（即默认行为）显示命令输出结果。

```
# pvs
  PV         VG     Fmt  Attr PSize  PFree
  /dev/sdb1  new_vg lvm2 a-   17.14G 17.14G
  /dev/sdc1  new_vg lvm2 a-   17.14G 17.09G
  /dev/sdd1  new_vg lvm2 a-   17.14G 17.14G
```

下面的命令采用 1000 的倍数显示命令输出结果。

```
#  pvs --units G
  PV         VG     Fmt  Attr PSize  PFree
  /dev/sdb1  new_vg lvm2 a-   18.40G 18.40G
  /dev/sdc1  new_vg lvm2 a-   18.40G 18.35G
  /dev/sdd1  new_vg lvm2 a-   18.40G 18.40G
```

还可以指定 (s) 扇区（默认为 512 字节）或自定义单位。

下面的示例以扇区数显示 `pvs` 命令的输出结果。

```
# pvs --units s
  PV         VG     Fmt  Attr PSize     PFree
  /dev/sdb1  new_vg lvm2 a-   35946496S 35946496S
  /dev/sdc1  new_vg lvm2 a-   35946496S 35840000S
  /dev/sdd1  new_vg lvm2 a-   35946496S 35946496S
```

下面的示例以 4MB 为单位显示 `pvs` 命令的输出结果。

```
# pvs --units 4m
  PV         VG     Fmt  Attr PSize    PFree
  /dev/sdb1  new_vg lvm2 a-   4388.00U 4388.00U
  /dev/sdc1  new_vg lvm2 a-   4388.00U 4375.00U
  /dev/sdd1  new_vg lvm2 a-   4388.00U 4388.00U
```

参考：https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/custom_report





---





# LVM详解

转自:http://freeloda.blog.51cto.com/2033581/1231089
**大纲**

```
    一、简介

    二、版本

    三、LVM 模块

    四、具体操作

        对添加的硬盘进行分区(fdisk /dev/[hs]d[a-z])

        对创建的分区创建物理卷(pvcreate)

        给逻辑卷创建逻辑容器(卷组）

        在卷组创建大小不同的逻辑卷(lvcreate)

        给以存在的卷组扩大容量

        实现在线扩大LVM容量

        实现缩减LVM容量(不支持在线缩减)

        减小卷组容量

        利用给LVM创建快照，并完成备份并还原数据12345678910111213141516171819202122232425
```

### 一,简介

```
LVM是 Logical Volume Manager（逻辑卷管理）的简写，它是Linux环境下对磁盘分区进行管理的一种机制，它由Heinz Mauelshagen在Linux 2.4内核上实现，于1998年发布到Linux社区中，它允许你在Linux系统上用简单的命令行管理一个完整的逻辑卷管理环境。1
```

### 二,版本

```
LVM1  最初的LVM与1998年发布，只在Linux内核2.4版本上可用，它提供最基本的逻辑卷管理。

LVM2  LVM-1的更新版本，在Linux内核2.6中才可用，它在标准的LVM-1功能外还提供了额外的功能。

查看：（测试机CentOS 5.5 X86_64）12345
[root@localhost ~]# uname -a 
Linux localhost.localdomain 2.6.18-194.el5 #1 SMP Fri Apr 2 14:58:14 EDT 2010 x86_64 x86_64 x86_64 GNU/Linux  
[root@localhost ~]# uname -r  
2.6.18-194.el5  
[root@localhost ~]# rpm -qa | grep lvm  
lvm2-2.02.56-8.el5  
[root@localhost ~]#1234567
```

### 三、LVM 模块

Physical volume (PV)、Volume group (VG)、Logical volume(LV)、 Physical extent (PE)，下面我们用一个简单的图来说明下物理卷、卷组、逻辑卷他们之间的关系(此图只是个人理解，仅供参考)
![这里写图片描述](https://upic-lisj.oss-cn-beijing.aliyuncs.com/uPic/1606108960-SouthEast.png)
简而言之：
逻辑卷的创建，就是将多块硬盘创建物理卷，而将这些物理卷以逻辑的形式总成一个容器，然后从这个容器里面创建大小不同的分区文件，而这个容器就是所谓的逻辑卷，而从这个容器里创建大小不同的分区文件，这个分区文件就叫做逻辑卷。嘿嘿，你懂了吗？ ^_^ ……

### 四、具体操作

1. 分区

```oz
[root@localhost ~]# fdisk –l #查看已存在的分区与硬盘
Disk /dev/sda: 21.4 GB, 21474836480 bytes   
255 heads, 63 sectors/track, 2610 cylinders    
Units = cylinders of 16065 * 512 = 8225280 bytes
   Device Boot      Start         End      Blocks   Id  System   
/dev/sda1   *           1          33      265041   83  Linux    
/dev/sda2              34        1308    10241437+  83  Linux    
/dev/sda3            1309        1945     5116702+  83  Linux    
/dev/sda4            1946        2610     5341612+   5  Extended    
/dev/sda5            1946        2072     1020096   82  Linux swap / Solaris
Disk /dev/sdb: 21.4 GB, 21474836480 bytes   
255 heads, 63 sectors/track, 2610 cylinders    
Units = cylinders of 16065 * 512 = 8225280 bytes
Disk /dev/sdb doesn't contain a valid partition table
Disk /dev/sdc: 21.4 GB, 21474836480 bytes   
255 heads, 63 sectors/track, 2610 cylinders    
Units = cylinders of 16065 * 512 = 8225280 bytes
Disk /dev/sdc doesn't contain a valid partition table
[root@localhost ~]# fdisk /dev/sdb #给/sdb分区,效果如下
Command (m for help): p
Disk /dev/sdb: 21.4 GB, 21474836480 bytes   
255 heads, 63 sectors/track, 2610 cylinders    
Units = cylinders of 16065 * 512 = 8225280 bytes
   Device Boot      Start         End      Blocks   Id  System   
/dev/sdb1               1         244     1959898+  8e  Linux LVM #注意修改分区类型为8e    
/dev/sdb2             245         488     1959930   8e  Linux LVM    
/dev/sdb3             489         732     1959930   8e  Linux LVM
Command (m for help):
    
[root@localhost ~]# partprobe #让内核重新读取一下硬盘
    
[root@localhost ~]# fdisk -l /dev/sdb
Disk /dev/sdb: 21.4 GB, 21474836480 bytes   
255 heads, 63 sectors/track, 2610 cylinders    
Units = cylinders of 16065 * 512 = 8225280 bytes
   Device Boot      Start         End      Blocks   Id  System   
/dev/sdb1               1         244     1959898+  8e  Linux LVM    
/dev/sdb2             245         488     1959930   8e  Linux LVM    
/dev/sdb3             489         732     1959930   8e  Linux LVM    
[root@localhost ~]#1234567891011121314151617181920212223242526272829303132333435363738
```

2.将物理分区与硬盘创建为物理卷(pvcreate)

```
[root@localhost ~]# pvcreate /dev/sdb[1-3] #将分区创建为物理卷   
  Physical volume "/dev/sdb1" successfully created    
  Physical volume "/dev/sdb2" successfully created    
  Physical volume "/dev/sdb3" successfully created    
[root@localhost ~]#
[root@localhost ~]# pvcreate /dev/sdc  #将硬盘创建为物理卷   
  Physical volume "/dev/sdc" successfully created
[root@localhost ~]# pvs #查看创建的物理卷   
  PV         VG   Fmt  Attr PSize  PFree     
  /dev/sdb1  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdb2  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdb3  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdc   myvg lvm2 a-   20.00G 20.00G12345678910111213
```

3.将物理卷(pv)创建为卷组(vgcreate)，名为myvg

```
[root@localhost ~]# vgcreate myvg /dev/sdb[1-3] /dev/sdc
  Volume group "myvg" successfully created   
[root@localhost ~]# vgs    
  VG   #PV #LV #SN Attr   VSize  VFree     
  myvg   4   0   0 wz--n- 25.60G 25.60G    
[root@localhost ~]#
[root@localhost ~]# vgdisplay   
  --- Volume group ---    
  VG Name               myvg #卷组名    
  System ID           
  Format                lvm2    
  Metadata Areas        4    
  Metadata Sequence No  1    
  VG Access             read/write    
  VG Status             resizable    
  MAX LV                0    
  Cur LV                0    
  Open LV               0    
  Max PV                0    
  Cur PV                4    
  Act PV                4    
  VG Size               25.60 GB    
  PE Size               4.00 MB #物理盘的基本单位：默认4MB    
  Total PE              6553    
  Alloc PE / Size       0 / 0 
  Free  PE / Size       6553 / 25.60 GB    
  VG UUID               wuNBgb-tP95-pVoX-ehHw-cMfN-hyem-PNMqwe    
[root@localhost ~]#12345678910111213141516171819202122232425262728
```

4.在卷组里创建逻辑卷并格式化、挂载使用

```
[root@localhost ~]# lvcreate -L 2G -n mylv1 myvg #创建逻辑卷   
  Logical volume "mylv1" created    
[root@localhost ~]# lvs #查看逻辑卷    
  LV    VG   Attr   LSize Origin Snap%  Move Log Copy%  Convert    
  mylv1 myvg -wi-a- 2.00G                                    
[root@localhost ~]# mke2fs -j /dev/myvg/mylv1 #格式化逻辑卷    
mke2fs 1.39 (29-May-2006)    
Filesystem label=    
OS type: Linux    
Block size=4096 (log=2)    
Fragment size=4096 (log=2)    
262144 inodes, 524288 blocks    
26214 blocks (5.00%) reserved for the super user    
First data block=0    
Maximum filesystem blocks=536870912    
16 block groups    
32768 blocks per group, 32768 fragments per group    
16384 inodes per group    
Superblock backups stored on blocks:     
        32768, 98304, 163840, 229376, 294912
Writing inode tables: done                          
Creating journal (16384 blocks): done    
Writing superblocks and filesystem accounting information: done
This filesystem will be automatically checked every 26 mounts or   
180 days, whichever comes first.  Use tune2fs -c or -i to override.    
[root@localhost ~]# mkdir /mydata #创建挂载目录    
[root@localhost ~]# mount /dev/myvg/mylv1 /mydata/ #挂载
[root@localhost ~]# mount #查看是否挂载成功   
/dev/sda2 on / type ext3 (rw)    
proc on /proc type proc (rw)    
sysfs on /sys type sysfs (rw)    
devpts on /dev/pts type devpts (rw,gid=5,mode=620)    
/dev/sda3 on /data type ext3 (rw)    
/dev/sda1 on /boot type ext3 (rw)    
tmpfs on /dev/shm type tmpfs (rw)    
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)    
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)    
/dev/mapper/myvg-mylv1 on /mydata type ext3 (rw)    
[root@localhost ~]#
[root@localhost ~]# ls /mydata/ #查看   
lost+found    
[root@localhost ~]# df –h #查看硬盘    
Filesystem            Size  Used Avail Use% Mounted on    
/dev/sda2             9.5G  1.8G  7.2G  20% /    
/dev/sda3             4.8G  138M  4.4G   4% /data    
/dev/sda1             251M   17M  222M   7% /boot    
tmpfs                  60M     0   60M   0% /dev/shm    
/dev/mapper/myvg-mylv1    
                      2.0G   68M  1.9G   4% /mydata    
[root@localhost ~]#1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950
```

5.发现卷组空间不够，我们扩大卷组空间

```
[root@localhost ~]# pvcreate /dev/sdd #将新硬盘/sdd加入物理卷中    
  Physical volume "/dev/sdd" successfully created
[root@localhost ~]# pvs #查看物理卷   
  /dev/cdrom: open failed: No medium found    
  PV         VG   Fmt  Attr PSize  PFree     
  /dev/sdb1  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdb2  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdb3  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdc   myvg lvm2 a-   20.00G 18.00G    
  /dev/sdd   myvg lvm2 a-   20.00G 20.00G    
[root@localhost ~]#
[root@localhost ~]# vgextend myvg /dev/sdd #扩展卷组   
  Volume group "myvg" successfully extended    
[root@localhost ~]# vgs #查看新增加的卷组    
    VG   #PV #LV #SN Attr   VSize  VFree     
  myvg   5   1   0 wz--n- 45.59G 43.59G    
[root@localhost ~]#1234567891011121314151617
```

6.扩展逻辑卷 (支持在线扩展)

```
将/dev/myvg/mylv1 扩展到4G，并且要求数据可以正常访问
[root@localhost ~]# cd /mydata/   
[root@localhost mydata]# touch index.html    
[root@localhost mydata]# echo "test" > index.html     
[root@localhost mydata]# cat index.html     
test
[root@localhost mydata]# vgs   
  /dev/cdrom: open failed: No medium found    
  VG   #PV #LV #SN Attr   VSize  VFree     
  myvg   5   1   0 wz--n- 45.59G 43.59G    
[root@localhost mydata]# lvextend -L +2G /dev/myvg/mylv1
   Extending logical volume mylv1 to 4.00 GB    
  Logical volume mylv1 successfully resized
[root@localhost mydata]# resize2fs -p /dev/myvg/mylv1 #通过 resize2fs 将文件系统的容量确实添加
resize2fs 1.39 (29-May-2006)    
Filesystem at /dev/myvg/mylv1 is mounted on /mydata; on-line resizing required    
Performing an on-line resize of /dev/myvg/mylv1 to 1048576 (4k) blocks.    
The filesystem on /dev/myvg/mylv1 is now 1048576 blocks long.
[root@localhost mydata]# lvs   
  LV    VG   Attr   LSize Origin Snap%  Move Log Copy%  Convert    
  mylv1 myvg -wi-ao 4.00G                                    
[root@localhost mydata]#
[root@localhost mydata]# cat index.html    
test    
[root@localhost mydata]# df -h    
Filesystem            Size  Used Avail Use% Mounted on    
/dev/sda2             9.5G  1.8G  7.2G  20% /    
/dev/sda3             4.8G  138M  4.4G   4% /data    
/dev/sda1             251M   17M  222M   7% /boot    
tmpfs                  60M     0   60M   0% /dev/shm    
/dev/mapper/myvg-mylv1    
                      4.0G   69M  3.7G   2% /mydata #成功增加了2G    
[root@localhost mydata]#123456789101112131415161718192021222324252627282930313233
```

7.缩减逻辑卷

```oz
查看逻辑卷使用空间状况

不能在线缩减，得先卸载

确保缩减后的空间大小依然能存储原有的所有数据

在缩减之前应该先强行检查文件，以确保文件系统处于一致性状态
1234567
将/dev/myvg/mylv1 缩减到1G，并且要求数据可以正常访问 (所以我们就按上面的提示在操作）
[root@localhost ~]#df –lh #查看已用空间大小
[root@localhost ~]# umount /dev/myvg/mylv1 #卸载分区
[root@localhost ~]# e2fsck -f /dev/myvg/mylv1 #强制检查文件系统
[root@localhost ~]# resize2fs /dev/myvg/mylv1 1G #缩减逻辑大小    
[root@localhost ~]# lvreduce -L 1G /dev/myvg/mylv1 #缩减物理边界大小
[root@localhost ~]# lvs #查看逻辑卷   
  /dev/cdrom: open failed: No medium found    
  LV    VG   Attr   LSize Origin Snap%  Move Log Copy%  Convert    
  mylv1 myvg -wi-ao 1.00G                                    
[root@localhost ~]# mount /dev/myvg/mylv1 /mydata
[root@localhost ~]# ls /mydata/   
index.html  lost+found    
[root@localhost ~]# cat /mydata/index.html     
test    
[root@localhost ~]#12345678910111213141516
```

8.缩减磁盘空间

发现物理磁盘空间使用不足，将其中一块硬盘或分区拿掉

```bash
pvmove /dev/sdb1 #将/dev/sdb1上存储的数据移到其它物理卷中

vgreduce myvg /dev/sdb1 #将/dev/sdb1从myvg卷组中移除

pvremove /dev/sdb1 #将/dev/sdb1从物理卷上移除
12345
[root@localhost ~]# pvs   
  /dev/cdrom: open failed: No medium found    
  PV         VG   Fmt  Attr PSize  PFree     
  /dev/sdb1  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdb2  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdb3  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdc   myvg lvm2 a-   20.00G 19.00G    
  /dev/sdd   myvg lvm2 a-   20.00G 20.00G    
[root@localhost ~]#
[root@localhost ~]# pvmove /dev/sdb1    
   No data to move for myvg
[root@localhost ~]# vgreduce myvg /dev/sdb1   
  Removed "/dev/sdb1" from volume group "myvg"
root@localhost ~]# pvremove /dev/sdb1   
  Labels on physical volume "/dev/sdb1" successfully wiped    
[root@localhost ~]# pvs    
  /dev/cdrom: open failed: No medium found    
  PV         VG   Fmt  Attr PSize  PFree     
  /dev/sdb2  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdb3  myvg lvm2 a-    1.87G  1.87G    
  /dev/sdc   myvg lvm2 a-   20.00G 19.00G    
  /dev/sdd   myvg lvm2 a-   20.00G 20.00G    
[root@localhost ~]#1234567891011121314151617181920212223
```

9.实现快照，进行备份还原

在/mnt/lvm目录上，我们将原始的目录文件进行快照，然后将/mydata目录中的内容清空，并进行还原

```shell
[root@localhost ~]# cd /mydata/   
[root@localhost mydata]# ls    
index.html  lost+found    
[root@localhost mydata]# cat index.html     
test    
[root@localhost mydata]# lvcreate -L 30M -n backup -s -p r /dev/myvg/mylv1 #-L 快照大小 –n:快照名称 –p 权限只读 –s 创建快照    
  Rounding up size to full physical extent 32.00 MB    
  Logical volume "backup" created    
[root@localhost mydata]# ll    
total 20    
-rw-r--r-- 1 root root     5 Jun 28 01:04 index.html    
drwx------ 2 root root 16384 Jun 28 00:47 lost+found    
[root@localhost mydata]# mkdir /tmp/backup #创建挂载目录    
[root@localhost mydata]# mount /dev/myvg/backup /tmp/backup/ #挂载
mount: block device /dev/myvg/backup is write-protected, mounting read-only   
[root@localhost mydata]# cd /tmp/backup/    
[root@localhost backup]# ls    
index.html  lost+found    
[root@localhost backup]# mkdir /tmp/lvmbackup #创建备份目录    
[root@localhost backup]# tar jcf /tmp/lvmbackup/sandy.tar.bz2 index.html  #打包并压缩文件    
[root@localhost backup]# cd ..    
[root@localhost tmp]# cd lvmbackup/    
[root@localhost lvmbackup]# ls #查看备份    
sandy.tar.bz2    
[root@localhost lvmbackup]# cd /mydata/    
[root@localhost mydata]# ll    
total 20    
-rw-r--r-- 1 root root     5 Jun 28 01:04 index.html    
drwx------ 2 root root 16384 Jun 28 00:47 lost+found    
[root@localhost mydata]# rm -rf * #删除所有文件    
[root@localhost mydata]#     
[root@localhost mydata]# ll    
total 0    
[root@localhost mydata]# tar xf /tmp/lvmbackup/sandy.tar.bz2 #还原备份数据    
[root@localhost mydata]# ll    
total 4    
-rw-r--r-- 1 root root 5 Jun 28 01:04 index.html    
[root@localhost mydata]# cat index.html     
test    
[root@localhost mydata]# df -h    
Filesystem            Size  Used Avail Use% Mounted on    
/dev/sda2             9.5G  1.8G  7.2G  21% /    
/dev/sda3             4.8G  138M  4.4G   4% /data    
/dev/sda1             251M   17M  222M   7% /boot    
tmpfs                  60M     0   60M   0% /dev/shm    
/dev/mapper/myvg-mylv1    
                     1008M   67M  901M   7% /mydata    
/dev/mapper/myvg-mylv1    
                     1008M   67M  901M   7% /tmp/backup    
[root@localhost mydata]#
```



---



# LVM讲解



如果使用一个命令时，提供未找到命令，说明我们需要安装一个包，若不知道包的名字，只知道命令名，我们可以用命令去搜：

比如：我们要安装lvm的包，但不知道真正的包名，只知道命令是`pvcreate`,我们可以用以下命令：

```oz
yum provides "/*/prvcreate"



yum provides "/*/pvcreate"   #根据命令pvcreate搜索软件包

yum install -y lvm2    #安装lvm工具

partprobe                  #更新分区表

vgremove                  #删除卷组

pvcreate                   #创建物理卷

pvs  或者 pvdisplay          #查看物理卷

vgcreate                   #创建卷组

vgs  或者 vgdisplay          #查看卷组

lvcreate                    #创建逻辑卷

lvs  或者 lvdisplay           #查看逻辑卷

lvresize -L                  #扩容逻辑卷指定逻辑卷的大小

e2fsck -f                   #检查磁盘错误

r esize2fs               #更新磁盘信息

xfs_growfs                  #XFS文件系统更新磁盘信息

vgextend                  #扩容卷组
```



```

```

1.PE  (Physical Extend) 物理拓展

2.PV  (Physical Volume) 物理卷

3.VG  (Volume Group) 卷组

4.LV  (Logical Volume) 逻辑卷

### 一、 lvm讲解

#### 1. 使用fdisk命令新建三个分区，并且使用t命令改变分区ID为8e

   ![img](https://upic-lisj.oss-cn-beijing.aliyuncs.com/uPic/1606108972-20180102181902787.png)

  新建好的分区如图：

   ![img](https://upic-lisj.oss-cn-beijing.aliyuncs.com/uPic/1606108979-20180102181908523.png)

#### \2. pvcreate   创建物理卷

\1. [root@localhost ~]# pvcreate /dev/sdb1                                              # 将 /dev/sdb1/ 、 /dev/sdb2/、  /dev/sdb3 创建为物理卷       

  WARNING: ext4 signature detected on /dev/sdb1 at offset 1080. Wipe it? [y/n]: y           # 提示是否签名，选择y

  Wiping ext4 signature on /dev/sdb1.

  Physical volume "/dev/sdb1" successfully created.

\2. [root@localhost ~]# pvcreate /dev/sdb2

  Physical volume "/dev/sdb2" successfully created.

\3. [root@localhost ~]# pvcreate /dev/sdb3

  WARNING: ext4 signature detected on /dev/sdb3 at offset 1080. Wipe it? [y/n]: y  

  Wiping ext4 signature on /dev/sdb3.

  Physical volume "/dev/sdb3" successfully create

#### \3. pvs  或者 pvdisplay  查看所有的物理卷

[root@localhost ~]# pvs                  #查看物理卷

 PV       VG Fmt Attr PSize PFree

 /dev/sdb1   lvm2 --- 1.00g 1.00g

 /dev/sdb2   lvm2 --- 1.00g 1.00g

 /dev/sdb3   lvm2 --- 1.00g 1.00g

#### 4.vgcreate  创建物理卷组 

  vgs 或者vgdisplay   查看物理卷组

\1. [root@localhost ~]# vgcreate vga /dev/sdb1 /dev/sdb2      #将/dev/sdb1/和/dev/sdb2创建为物理卷组，卷组的名字为：vga

  Volume group "vga" successfully created

\2. [root@localhost ~]# vgs                                 #使用vgs查看物理卷组   

  VG #PV #LV #SN Attr  VSize VFree

  vga  2  0  0 wz--n- 1.99g 1.99g

#### \5. lvcreate  创建逻辑卷  -L 指定大小  -n指定逻辑卷的名称

  lvs 或者 lvdisplay   查看逻辑卷

\1. [root@localhost ~]# lvcreate -L 100M -n lva vga            创建一个逻辑卷lva，指定大小为lva                   

  Logical volume "lva" created.

\2. [root@localhost ~]# lvs

  LV  VG Attr    LSize  Pool Origin Data% Meta% Move Log Cpy%Sync Convert

  lva vga -wi-a----- 100.00m 

#### \7. 格式化逻辑卷，挂载逻辑卷

\1. [root@localhost ~]# mkfs.ext4 /dev/vga/lva            # 将逻辑卷/lva/格式化为ext4文件系统

\2. [root@localhost ~]# mount /dev/vga/lva /mnt/         # 将逻辑卷/lva/挂载到mnt下

\3. [root@localhost ~]# df -h

  文件系统         容量   已用    可用   已用%   挂载点

  /dev/sda3       16G   1.1G   15G    7%      /

  devtmpfs       911M   0     911M   0%     /dev

  tmpfs          920M   0     920M   0%    /dev/shm

  tmpfs          920M  17M   903M  2%   /run

  tmpfs          920M   0     920M  0%    /sys/fs/cgroup

  /dev/sda1      197M 113M   85M   58%   /boot

  tmpfs          184M   0     184M    0%   /run/user/0

  /dev/mapper/vga-lva  93M    1.6M   85M  2% /mnt     挂载到mnt下的为 /dev/vga/lva，显示的名字为 /dev/mapper/vga-lva  ，使用ls查看两个文件实际上指向是同一个文件../dm-0

\4. [root@localhost ~]# ls -l /dev/mapper/vga-lva

  lrwxrwxrwx. 1 root root 7 12月 30 18:33 /dev/mapper/vga-lva -> ../dm-0

\5. [root@localhost ~]# ls -l /dev/vga/lva

  lrwxrwxrwx. 1 root root 7 12月 30 18:33 /dev/vga/lva -> ../dm-0

### 二、逻辑卷的扩容和缩容

针对ext4的文件系统扩容：

\1. lvresize -L 扩容逻辑卷，-L指定逻辑卷的大小

\1. [root@localhost ~]# umount /mnt                     #扩容逻辑卷之前要先将逻辑卷卸载

\2. [root@localhost ~]# lvresize -L 300M /dev/vga/lva       #扩容逻辑卷lva，并指定逻辑卷的大小为300M 

  Size of logical volume vga/lva changed from 100.00 MiB (25 extents) to 300.00 MiB (75 extents).  #逻辑卷由100M变为300M

  Logical volume vga/lva successfully resized.

\2. e2fsck -f  检查磁盘错误

[root@localhost ~]# e2fsck -f /dev/vga/lva      #扩容后检查lva磁盘是否存在错误

e2fsck 1.42.9 (28-Dec-2013)

第一步: 检查inode,块,和大小

第二步: 检查目录结构

第3步: 检查目录连接性

Pass 4: Checking reference counts

第5步: 检查簇概要信息

/dev/vga/lva: 13/25688 files (7.7% non-contiguous), 8899/102400 blocks

\3. r esize2fs  更新逻辑卷信息

[root@localhost ~]# resize2fs /dev/vga/lva        #更新磁盘lva的信息

resize2fs 1.42.9 (28-Dec-2013)

Resizing the filesystem on /dev/vga/lva to 307200 (1k) blocks.

The filesystem on /dev/vga/lva is now 307200 blocks long.

针对ext4的文件系统缩容：

\1.  先使用e2fsck 检查磁盘错误

[root@localhost ~]# umount /mnt            #先将挂载的磁盘进行卸载

[root@localhost ~]# e2fsck -f /dev/vga/lva

e2fsck 1.42.9 (28-Dec-2013)

第一步: 检查inode,块,和大小

第二步: 检查目录结构

第3步: 检查目录连接性

Pass 4: Checking reference counts

第5步: 检查簇概要信息

/dev/vga/lva: 13/75088 files (7.7% non-contiguous), 15640/307200 blocks

\2. 使用resize2fs更新磁盘信息  

[root@localhost ~]# resize2fs /dev/vga/lva 100M        #注意更新的磁盘信息要将缩小到多大写上去

resize2fs 1.42.9 (28-Dec-2013)

Resizing the filesystem on /dev/vga/lva to 102400 (1k) blocks.

The filesystem on /dev/vga/lva is now 102400 blocks long.

\3. 使用lvresize缩减磁盘 

[root@localhost ~]# lvresize -L 100M /dev/vga/lva            #缩减lva到100M   

 WARNING: Reducing active logical volume to 100.00 MiB.

 THIS MAY DESTROY YOUR DATA (filesystem etc.)

Do you really want to reduce vga/lva? [y/n]: y               #提示是否缩减，选择y 

 Size of logical volume vga/lva changed from 300.00 MiB (75 extents) to 100.00 MiB (25 extents).

 Logical volume vga/lva successfully resized.               #缩减成功

针对xfs文件系统的扩容

\1. 将磁盘格式化为xfs文件系统

[root@localhost ~]# mkfs.xfs -f /dev/vga/lva

\2. 挂载磁盘，XFS文件系统进行扩容的时候需要挂载磁盘

[root@localhost ~]# mount /dev/vga/lva /mnt            #将磁盘挂载到mnt下

[root@localhost ~]# df -h

文件系统       容量 已用 可用 已用% 挂载点

/dev/sda3       16G 1.1G  15G  7% /

devtmpfs       911M   0 911M  0% /dev

tmpfs        920M   0 920M  0% /dev/shm

tmpfs        920M  17M 904M  2% /run

tmpfs        920M   0 920M  0% /sys/fs/cgroup

/dev/sda1      197M 113M  85M  58% /boot

tmpfs        184M   0 184M  0% /run/user/0

/dev/mapper/vga-lva  97M 5.2M  92M  6% /mnt     #可以看到大小为100M

\3. 使用lvresize扩容

[root@localhost ~]# lvresize -L 300M /dev/vga/lva        #  指定扩容的大小为300M

 Size of logical volume vga/lva changed from 100.00 MiB (25 extents) to 300.00 MiB (75 exten

 Logical volume vga/lva successfully resized.

\4. xfs_growfs  扩展XFS文件系统

[root@localhost ~]# xfs_growfs /dev/vga/lva

meta-data=/dev/mapper/vga-lva  isize=512  agcount=4, agsize=6400 blks

​       =            sectsz=512  attr=2, projid32bit=1

​       =            crc=1    finobt=0 spinodes=0

data   =            bsize=4096  blocks=25600, imaxpct=25

​       =            sunit=0   swidth=0 blks

naming  =version 2       bsize=4096  ascii-ci=0 ftype=1

log      =internal        bsize=4096  blocks=855, version=2

​         =            sectsz=512  sunit=0 blks, lazy-count=1

realtime =none          extsz=4096  blocks=0, rtextents=0

data blocks changed from 25600 to 76800

#### 三、卷组的扩容

\1. vgextend  扩容卷组

[root@localhost ~]# vgs

 VG #PV #LV #SN Attr  VSize VFree

 vga  2  1  0 wz--n- 1.99g <1.70g                 #卷组vga的大小为2G

[root@localhost ~]# vgextend vga /dev/sdb3

 Volume group "vga" successfully extended          #将/dev/sdb3/加入到卷组vga

[root@localhost ~]# vgs

 VG #PV #LV #SN Attr  VSize VFree

 vga  3  1  0 wz--n- <2.99g <2.70g               #卷组vga的大小变为3G
